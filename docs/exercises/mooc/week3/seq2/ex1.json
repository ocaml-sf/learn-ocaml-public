[
  {
    "learnocaml_version": "2",
    "kind": "exercise",
    "title": "Symbolic Manipulation of Arithmetic Expressions",
    "stars": 2
  },
  {
    "id": "ex1",
    "prelude": "type exp =\n  | EInt of int\n  | EAdd of exp * exp\n  | EMul of exp * exp\n\nlet example =\n  EAdd (EInt 1, EMul (EInt 2, EInt 3))\n",
    "template": "let my_example =\n  \"Replace this string with your example.\" ;;\n\nlet eval e =\n  \"Replace this string with your implementation.\" ;;\n\nlet factorize e =\n  \"Replace this string with your implementation.\" ;;\n\nlet expand e =\n  \"Replace this string with your implementation.\" ;;\n\nlet simplify e =\n  \"Replace this string with your implementation.\" ;;\n",
    "descr": [
      [
        "",
        "<p>\n  Abstract syntax trees are a convenient way to represent a syntactic\n  expression in a structured way.\n\n  <br/>\n\n  Let us consider arithmetic expressions formed by the\n  following rules:\n  <ol type=\"a\">\n    <li>\n      an integer is an arithmetic expression ;\n    </li>\n    <li>\n      if <code>lhs</code> and <code>rhs</code> are arithmetic\n      expressions then <code>lhs + rhs</code> is an arithmetic\n      expression;\n    </li>\n    <li>\n      if <code>lhs</code> and <code>rhs</code> are arithmetic\n      expressions then <code>lhs * rhs</code> is an arithmetic\n      expression.\n    </li>\n  </ol>\n  Such an expression can be represented by a value of\n  type <code>exp</code> as defined in the given prelude (as well as\n  the definition of <code>1 + 2 * 3</code> as an example).\n</p>\n\n<ol>\n  <li>\n    Write the expression <code>2 * 2 + 3 * 3</code> in a\n    variable <code>my_example</code>.\n  </li>\n  <li>\n    Write a function <code>eval : exp -> int</code> that computes the\n    value of an arithmetic expression. The evaluation rules are:\n    <ol type=\"a\">\n      <li>\n\u0009If the expression is an integer <code>x</code>, the evaluation\n\u0009is <code>x</code>.\n      </li>\n      <li>\n\u0009If the expression is <code>lhs + rhs</code>\n\u0009and <code>lhs</code> evaluates to <code>x</code> and\n\u0009<code>rhs</code> evaluates to <code>y</code>, then the\n\u0009evaluation is <code>x + y</code>.\n      </li>\n      <li>\n\u0009If the expression is <code>lhs * rhs</code>\n\u0009and <code>lhs</code> evaluates to <code>x</code> and\n\u0009<code>rhs</code> evaluates to <code>y</code>, then the\n\u0009evaluation is <code>x * y</code>.\n      </li>\n    </ol>\n  </li>\n  <li>\n    If an expression is of the form <code>a * b + a * c</code>\n    then <code>a * (b + c)</code> is a factorized equivalent\n    expression.\n\n    <br/>\n\n    Write a function <code>factorize : exp -> exp</code> that\n    implements this transformation on its input exp if it has the\n    shape <code>a * b + a * c</code> or does nothing otherwise.\n  </li>\n  <li>\n    Write the reverse transformation of <code>factorize</code>,\n    <code>expand : exp -> exp</code>, which turns an expression of the\n    shape <code>a * (b + c)</code> into <code>a * b + a *\n    c</code>.\n  </li>\n  <li>\n    Implement a function <code>simplify: exp -> exp</code> which takes\n    an expression <code>e</code> and:\n    <ol type=\"a\">\n      <li>\n\u0009If <code>e</code> is of the shape <code>e * 0</code>\n\u0009or <code>0 * e</code>, returns the expression <code>0</code>.\n      </li>\n      <li>\n\u0009If <code>e</code> is of the shape <code>e * 1</code>\n\u0009or <code>1 * e</code>, returns the expression <code>e</code>.\n      </li>\n      <li>\n\u0009If <code>e</code> is of the shape <code>e + 0</code>\n\u0009or <code>0 + e</code>, returns the expression <code>e</code>.\n      </li>\n    </ol>\n   and does nothing otherwise.\n  </li>\n</ol>\n\n<p>\n  <strong>Remarks:</strong>\n  <ol>\n    <li>\n      The symbols (<code>a</code>, <code>b</code>, <code>c</code>\n      and <code>e</code>) can match any expressions, not just\n      integers.\n    </li>\n    <li>\n      these are a syntactical rewritings, so two expressions are\n      considered equal if and only if they are exactly the same\n      expressions (simply use the <code>=</code> operator to check\n      that).\n    </li>\n    <li>\n      The rewritings have to be done on the first level of the\n      expression only, not recursively and not deeper in the\n      expression. If the toplevel expression does not match the\n      expected pattern, simply return the expression untouched.\n    </li>\n  </ol>\n</p>\n"
      ]
    ],
    "prepare": "",
    "test": "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",
    "solution": "qnLkunzAS49BomnLQXyBYWM9LA6VGRFdBEV2FR815YZqr/MoVQWnES2hqfWobhZN9X7U2pY0wP+6TNURolLZf9I/Ck6IOtwOi4QsvM1AI+QpAwVSp4UEdydBXg1MrnKEHJra/Jh0FrTQOSXTFosIbvnIhS4FToW6fAU461q1qGefZfnoZJo5aRWGPZN3PMwdJ61MABFLUUwDEBFJENnFyX3fSXE2Mc24ITDbw0ijaSCBYsUmYmf7d+FVjVTl+srbEHgR3l61pkbJt8frlEdjrntL/VLBcQTn4pF4/pneIxQ1zeb1/AtWsLVZ0wcPOQyjdMvNSxFr3PmxTUTImILl4qwrx45tyH7dGIZtjlpepXFc+lkMER/d2Do1ERkRs37sWqhFPVl7kkdp1+SGq4raIIElzWFJ1rv7xRumObgrpehH0/IQLFSGFxznKvPHVCjcPjSVTgjmNNFwGR0QAgl7hSH4yqiYDRvd9mlnllIqYqup7IQ8hEcRv+pxI2nH8qodaj48wz8ZUcEMnyHTTDDBPjwIZlpRRR/1+RlPPoCgfM6b9GsoEDT0DDxka3Dlq0x5jTTSK7loqrqrE4MRxy3Xjnc8T/Fv23cFi4RqhYRF04IsTqA7/PcRsH/ZFuluii+EUJL+dMgP1cW3YDqDZTFIwqDsgQLFCoiMmQMY72rCcH8fZajqA06nbFzONN1NW+5nNlF2RTtZGUVw2XoAXLy5uVLlFTkE0Nt+3y8ouN7WszmEPNFmYo3DePV4nB77JxzbBopCUThQpprEfybxu5==",
    "max-score": 44
  },
  null
]