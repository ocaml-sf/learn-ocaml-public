[
  {
    "learnocaml_version": "2",
    "kind": "exercise",
    "title": "Parser Combinators",
    "stars": 3
  },
  {
    "id": "parser_combinators",
    "prelude": "",
    "template": "(* The type [parser] satisfies the monad API: [return], [>>=]. *)\n\n(* [return a] always succeeds, consumes no input, and returns [a]. *)\n\nlet return (a : 'a) : 'a parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* [p >>= f] is the sequential composition of the parsers [p] and [f]. *)\n\nlet (>>=) (p : 'a parser) (f : 'a -> 'b parser) : 'b parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The type [parser] supports the nondeterminism monad API: [fail], [choose],\n   [at_most_once]. *)\n\n(* The parser [fail] accepts the empty language: it always fails. *)\n\nlet fail : 'a parser =\n  fun cursor ->\n    (* TO DO: Define this function. *)\n    raise TODO\n\n(* The parser [choose p q] accepts the union of the languages accepted\n   by the parsers [p] and [q]. *)\n\nlet choose (p : 'a parser) (q : 'a parser) : 'a parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The parser [at_most_once p] accepts the same language as [p], but\n   accepts each input string in at most one way. *)\n\nlet at_most_once (p : 'a parser) : 'a parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The type [parser] supports the applicative functor API: [map], [<&>]. *)\n\n(* [map f p] accepts the same language as the parser [p], and applies the\n   function [f] to every result produced by [p]. *)\n\nlet map (f : 'a -> 'b) (p : 'a parser) : 'b parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The parser [p <&> q] accepts the concatenation of the languages accepted\n   by the parsers [p] and [q]. For each value [a] returned by [p] and for\n   each value [b] returned by [q], it returns the pair [(a, b)]. *)\n\nlet (<&>) (p : 'a parser) (q : 'b parser) : ('a * 'b) parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The parser [p >> q] accepts the concatenation of the languages accepted\n   by the parsers [p] and [q]. For each value [a] returned by [p] and for\n   each value [b] returned by [q], it returns just [b]. *)\n\nlet (>>) (p : 'a parser) (q : 'b parser) : 'b parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The parser [p << q] accepts the concatenation of the languages accepted\n   by the parsers [p] and [q]. For each value [a] returned by [p] and for\n   each value [b] returned by [q], it returns just [a]. *)\n\nlet (<<) (p : 'a parser) (q : 'b parser) : 'a parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The type [parser] supports a number of operations that are specific of the\n   parser combinator monad. The most basic two are [any] and [eof]. On top of\n   these two, more combinators are defined, including [sat], [char], [digit],\n   and so on. *)\n\n(* [any] succeeds if and only if the cursor is currently not at the end of the\n   input stream. It consumes and returns the next input token. *)\n\nlet any : token parser =\n  fun cursor ->\n    (* TO DO: Define this function. *)\n    raise TODO\n\n(* [eof] succeeds if and only if the cursor is currently at the end of the\n   input stream. It consumes nothing, and returns [()]. It is idempotent:\n   [eof >> eof] is the same as [eof]. *)\n\nlet eof : unit parser =\n  fun cursor ->\n    (* TO DO: Define this function. *)\n    raise TODO\n\n(* The parser [sat p] consumes and returns the next input token if this\n   token satisfies the predicate [p]. It fails otherwise. *)\n\nlet sat (p : token -> bool) : token parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The parser [char c] consumes and returns the next input token if this\n   token is the character [c]. It fails otherwise. *)\n\nlet char (c : token) : token parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The parser [digit] consumes the next token if this token is a character\n   in the range ['0'..'9']. It returns an integer between 0 and 9. *)\n\nlet is_digit c : bool =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nlet decode_digit c : int =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nlet digit: int parser =\n  (* TO DO: Define this parser. *)\n  fail\n\n(* Iteration. *)\n\n(* The parser [star p] accepts the concatenation of any number of strings\n   accepted by the parser [p]. The parser [plus p] accepts the concatenation\n   of any nonzero number of strings accepted by the parser [p]. *)\n\n(* The parser [p] must be non-nullable, that is, must not accept the empty\n   string. This ensures that the mutual recursion in the definitions of [star]\n   and [plus] is well-founded: before a recursive call takes place, at list\n   one input token is consumed. *)\n\nlet rec star (p : 'a parser) : 'a list parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nand plus (p : 'a parser) : 'a list parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* The parsers [number_lax] and [number] both recognize a nonempty sequence of\n   digits and return its meaning as an integer. Whereas [number_lax] accepts a\n   sequence of arbitrary (nonzero) length, [number] has longest-match semantics:\n   it will recognize only a sequence of maximum length (thus returns at most one\n   result). *)\n\nlet decode_digits (digits : int list) : int =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nlet number_lax : int parser =\n  (* TO DO: Define this parser. *)\n  fail\n\nlet number : int parser =\n  (* TO DO: Define this parser. *)\n  fail\n\n(* Support for iterated applications of left-associative operators. *)\n\ntype 'a op =\n  'a -> 'a -> 'a\n\n(* The parser [additive_op] recognizes one of the characters '+' or '-'\n   and interprets it as the corresponding operation on integers. *)\n\nlet additive_op : int op parser =\n  (* TO DO: Define this parser. *)\n  fail\n\n(* The parser [multiplicative_op] recognizes one of the characters '*' or '/'\n   and interprets it as the corresponding operation on integers. *)\n\nlet multiplicative_op : int op parser =\n  (* TO DO: Define this parser. *)\n  fail\n\n(* The parser [chainl1 p op] recognizes the language [p (op p)*]. A string in\n   this language is interpreted as a left-associative chain of applications of\n   operators to values. *)\n\nlet chainl1 (p : 'a parser) (op : 'a op parser) : 'a parser =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* A simple grammar of additions and subtractions of constants. *)\n\n(* A sum is a nonempty list of numbers, separated by additive operators, which\n   are considered left-associative. *)\n\nlet sum : int parser =\n  (* TO DO: Define this parser. *)\n  fail\n\n(* The higher-order function [fix] allows defining a recursive parser,\n   that is, a parser whose definition refers to itself. Left recursion\n   is forbidden: that is, a recursive call is permitted only after a\n   nonempty segment of the input has been consumed. *)\n\nlet fix (pp : 'a parser -> 'a parser) : 'a parser =\n  let rec p cursor = pp p cursor in\n  p\n\n(* A simple grammar of arithmetic expressions. *)\n\n(* A term is a nonempty list of factors, separated by additive operators,\n   which are left-associative. *)\n\n(* A factor is a nonempty list of atoms, separated by multiplicative\n   operators, which are left-associative. *)\n\n(* An atom is either a number or a term surrounded with parentheses. *)\n\nlet rec term : int parser =\n  (* TO DO: Define this parser. *)\n  fail\n",
    "descr": [
      [
        "",
        "<h1 id=\"Parser-Combinators\">Parser Combinators</h1>\n\n<p>In this exercise, on top of an implementation of the nondeterminism monad\n(which is given), we build a set of <strong>parser combinators</strong> and use them to\nbuild a parser for a simple language of arithmetic expressions.</p>\n<h2 id=\"Parsers\">Parsers</h2>\n\n<p>A <strong>parser</strong> is an algorithm which recognizes the structure of a piece of text\nand produces a convenient representation of this structure.</p>\n<p>For instance, a parser for arithmetic expressions, applied to the string\n<code>&quot;1+2*3&quot;</code>, would recognize that this sequence of characters represents an\naddition whose left-hand operand is the literal <code>1</code> and whose right-hand\noperand is the multiplication of the literals <code>2</code> and <code>3</code>. It would then\npossibly return an <em>abstract syntax tree</em> (a data structure that records this\ninformation in a natural way), or possibly evaluate this arithmetic expression\non the fly and return just the <em>integer value</em> <code>7</code>. It is up to us, when we\ndefine a parser, to decide what type of result it returns.</p>\n<p>A parser for arithmetic expressions, applied to the string <code>&quot;1+2)&quot;</code>, would\nreject this ill-formed input. Thus, a parser can return zero results, or in\nother words, <em>fail</em>.</p>\n<p>The reason why we view the arithmetic expression <code>&quot;1+2*3&quot;</code> as an addition\n(whose right-hand operand is a multiplication) is that we follow the usual\nconvention that &quot;multiplicative operators have priority over additive\noperators&quot;. In the absence of this convention, the input string <code>&quot;1+2*3&quot;</code>\nwould be <em>ambiguous</em>. A parser for arithmetic expressions, applied to this\nstring, would have to indicate that the value of this expression is either\n<code>7</code> or <code>9</code>, depending on how it is interpreted. Thus, in general, a parser\ncan return <em>multiple results</em>.</p>\n<p>These remarks suggest that a parser is a nondeterministic computation. Thus,\nwe can and should take advantage of the <em>nondeterminism monad</em> to facilitate\nthe implementation of parsers.</p>\n<p>The nondeterminism monad is the topic of several other exercises, where it\nis implemented in different ways,\nusing\n<a onclick=\"top.location='/exercises/nondet_monad_seq/';\" href=''>sequences</a>,\nusing\n<a onclick=\"top.location='/exercises/nondet_monad_cont/';\" href=''>continuations</a>,\nand as an\n<a onclick=\"top.location='/exercises/nondet_monad_defun/';\" href=''>abstract machine</a>.\nAll three implementations present the same API to the user.\nIn the following sections,\nwe explain the nondeterminism monad and its API.\nWe also recall the API of sequences, offered by the module <code>Seq</code>.\nThen, we come back to parsers.</p>\n<h2 id=\"The-Nondeterminism-Monad\">The Nondeterminism Monad</h2>\n\n<p>When searching for the solution of a problem, one must typically\nexplore multiple choices. If a series of choices lead to a failure\n(a dead end), then one must backtrack and explore another avenue.</p>\n<p>There are a number of ways in which nondeterminism and backtracking\ncan be implemented. Regardless of which implementation mechanism is\nchosen, it is desirable to hide it behind an abstraction barrier and\npresent the end user with <strong>a simple API for constructing an executing\nnondeterministic computations</strong>.</p>\n<p>This API is known as the <strong>nondeterminism monad</strong>. It offers the\nfollowing key elements:</p>\n<ul><li><p>A type <code>&#39;a m</code>, the type of computations that yield results of type\n <code>&#39;a</code>.</p>\n</li><li><p>A number of constructor functions for constructing computations,\n such as <code>fail: &#39;a m</code>, which represents failure, and <code>choose: &#39;a m\n  -&gt; &#39;a m -&gt; &#39;a m</code>, which expresses a nondeterministic choice\n between two computations.</p>\n</li><li><p>A single observation function, <code>sols: &#39;a m -&gt; &#39;a Seq.t</code>, which\n converts a computation to a sequence of results, thereby allowing\n the user to execute this computation and observe its results. The\n name <code>sols</code> stands for <code>solutions</code>.</p>\n</li></ul>\n\n<p>A monad can be thought of as a <strong>mini-programming language</strong> where\ncomputations are first-class citizens: we have a type of\ncomputations, ways of building computations, and a way of executing\ncomputations.</p>\n<p>A computation in the nondeterminism monad can produce zero, one, or\nmore results. Indeed, a computation that fails produces zero\nresults. A computation that succeeds normally produces one result.\nA computation that uses <code>choose</code> can produce more than one result.\nIt is in fact possible to construct computations that produce an\ninfinite number of results!</p>\n<h2 id=\"The-Nondeterminism-Monad-39-s-API\">The Nondeterminism Monad&#39;s API</h2>\n\n<p>The signature, or API, of the nondeterminism monad is as follows:</p>\n<pre><code>module NonDet : sig\n\n  (* Type. *)\n  type &#39;a m\n\n  (* Constructor functions. *)\n  val return: &#39;a -&gt; &#39;a m\n  val (&gt;&gt;=): &#39;a m -&gt; (&#39;a -&gt; &#39;b m) -&gt; &#39;b m\n  val fail: &#39;a m\n  val choose: &#39;a m -&gt; &#39;a m -&gt; &#39;a m\n  val delay: (unit -&gt; &#39;a m) -&gt; &#39;a m\n\n  (* Observation function. *)\n  val sols: &#39;a m -&gt; &#39;a Seq.t\n\nend</code></pre>\n\n<p>As explained above, a value of type <code>&#39;a m</code> is <strong>a description of a\ncomputation</strong>, which, once executed, produces a sequence of results\nof type <code>&#39;a</code>.</p>\n<p>To execute a computation <code>m</code>, one must first convert it to a\nsequence of type <code>&#39;a Seq.t</code>, whose elements can then be demanded,\none by one. (More information on the module <code>Seq</code> is given below.)\nThis conversion is performed by the observation function <code>sols</code>.</p>\n<p>The call <code>sols m</code> typically terminates in constant time; the actual\ncomputation described by <code>m</code> takes place only when the elements of\nthe sequence <code>sols m</code> are demanded, and only insofar as necessary to\nproduce the elements that are demanded. For instance, applying\n<code>Seq.head</code> to the sequence <code>sols m</code> forces the computation to\nproceed up to the point where it is able to produce its first\nresult.</p>\n<p>The constructor functions <code>return</code> and <code>(&gt;&gt;=)</code> exist in all monads.\n(They are also known as <code>return</code> and <code>bind</code>.) <code>return</code> constructs a\ntrivial computation, which does nothing except return a value,\nwhereas <code>(&gt;&gt;=)</code> constructs the sequential composition of two\ncomputations. Together, they allow constructing the sequential\ncomposition of an arbitrary number of computations.</p>\n<ul><li><p>The computation <code>return v</code> succeeds exactly once with the value\n <code>v</code>. In other words, the sequence of values that it produces is\n the singleton sequence composed of just <code>v</code>.</p>\n</li><li><p>The computation <code>m1 &gt;&gt;= m2</code> is the sequential composition of the\n computations <code>m1</code> and <code>m2</code>. This composition operator is\n asymmetric: whereas its first argument <code>m1</code> is a computation of\n type <code>&#39;a m</code>, its second argument <code>m2</code> is a function of type <code>a -&gt;\n  &#39;b m</code>. Every value <code>x</code> produced by <code>m1</code> is passed to <code>m2</code>,\n yielding a computation <code>m2 x</code>. The sequence of values produced by\n <code>m1 &gt;&gt;= m2</code> is the concatenation of the sequences of values\n produced by the computations <code>m2 x</code>, where <code>x</code> ranges over the\n values produced by <code>m1</code>.</p>\n</li></ul>\n\n<p>The constructor functions <code>fail</code> and <code>choose</code> are specific of the\nnondeterminism monad. <code>fail</code> can be thought of as a 0-ary\ndisjunction, whereas <code>choose</code> is a binary disjunction. Together,\nthey allow constructing the disjunction of an arbitrary number of\ncomputations.</p>\n<ul><li><p>The computation <code>fail</code> returns no result. In other words, it\n produces an empty sequence of values.</p>\n</li><li><p>The sequence of values produced by <code>choose m1 m2</code> is the\n concatenation of the sequences of values produced by <code>m1</code>\n and by <code>m2</code>.</p>\n</li></ul>\n\n<p>The constructor function <code>delay</code> is not exploited in this exercise on parser\ncombinators. Although we could implement a <code>delay</code> parser combinator (and, in\na real-world implementation of parser combinators, this combinator would be\nuseful), in this exercise, we won&#39;t.</p>\n<h2 id=\"The-Seq-API\">The <code>Seq</code> API</h2>\n\n<p>The type of <strong>on-demand sequences</strong> is defined in a module named <code>Seq</code>.\nBeginning with version 4.07,\nthis module is part of OCaml&#39;s standard library.</p>\n<pre><code>module Seq : sig\n\n  type &#39;a t = unit -&gt; &#39;a node\n\n  and +&#39;a node =\n  | Nil\n  | Cons of &#39;a * &#39;a t\n\n  val nil : &#39;a t\n  val cons: &#39;a -&gt; &#39;a t -&gt; &#39;a t\n  val singleton: &#39;a -&gt; &#39;a t\n\n  val map: (&#39;a -&gt; &#39;b) -&gt; &#39;a t -&gt; &#39;b t\n  val concat: &#39;a t -&gt; &#39;a t -&gt; &#39;a t\n  val flatten: &#39;a t t -&gt; &#39;a t\n\n  val take: int -&gt; &#39;a t -&gt; &#39;a t\n\n  val head: &#39;a t -&gt; &#39;a option\n\n  val of_list: &#39;a list -&gt; &#39;a t\n  val to_list: &#39;a t -&gt; &#39;a list\n\nend</code></pre>\n\n<p>This data type is closely related to the algebraic data type of lists.\nIndeed, if instead of <code>unit -&gt; &#39;a node</code> one had written just <code>&#39;a node</code>,\nthen this data type would have been isomorphic to the type of lists.</p>\n<p>The presence of <code>unit -&gt; ...</code> indicates that a sequence is in fact a function.\nCalling this function, by applying it to the value <code>()</code>, amounts to requesting\nthe head of the sequence. This head can be either <code>Nil</code>, which means that the\nsequence is empty, or <code>Cons (x, xs)</code>, which means that the first element of\nthe sequence is <code>x</code> and the remaining elements form another sequence <code>xs</code>. It\nis worth noting that <code>xs</code> is itself a function, so the elements of the\nsequence <code>xs</code> need not be explicitly computed until <code>xs</code> is applied.</p>\n<p>Sequences are closely related to <em>iterators</em> in object-oriented languages,\nsuch as C++ and Java. Yet, sequences are much simpler than iterators, for\ntwo reasons:</p>\n<ul><li><p>they involve no mutable state;</p>\n</li><li><p>they are just as easy to construct and to use as ordinary lists.</p>\n</li></ul>\n\n<p>The functions <code>nil</code>, <code>cons</code>, and <code>singleton</code> are constructor functions.</p>\n<p>The functions <code>map</code>, <code>concat</code>, <code>flatten</code> are analogues for sequences\nof the standard list functions <code>List.map</code>, <code>(@)</code>, and\n<code>List.flatten</code>.</p>\n<p>The function <code>Seq.take</code> truncates a sequence at a certain length:\n<code>Seq.take n xs</code> is a sequence that begins like <code>xs</code> but has at most\n<code>n</code> elements.</p>\n<p>The function <code>Seq.head</code> demands the first element of a sequence. If\nthe sequence begins with an element <code>x</code>, then <code>Some x</code> is returned;\notherwise, <code>None</code> is returned. This forces enough computation to\ntake place so as to be able to produce the first element of the\nsequence.</p>\n<p>The functions <code>Seq.of_list</code> and <code>Seq.to_list</code> convert between lists\nand sequences, both ways. One must keep in mind that applying\n<code>Seq.to_list</code> to a sequence <code>xs</code> causes all of its elements to be\ndemanded: that is, it forces all of the suspended computations to\ntake place. In particular, if <code>xs</code> is an infinite sequence, then\n<code>Seq.to_list xs</code> does not terminate.</p>\n<h2 id=\"What-39-s-a-Parser\">What&#39;s a Parser?</h2>\n\n<p>As explained earlier, a parser reads a piece of input text and produces zero,\none, or more results, where each result represents a possible interpretation\nof this text.</p>\n<p>We wish to construct parsers in a compositional way: that is, we wish to\nconstruct complex parsers by combining simpler parsers. Thus, we must allow\nfor the possibility that a parser does not necessarily read <em>all</em> of the\ninput, from beginning to end, but reads only a <em>fragment</em> of the input. In\nother words, if a <strong>cursor</strong> is a pointer into the input text, then a parser\nmust receive an initial cursor as an argument. Furthermore, instead of\nreturning just a number of <em>results</em>, a parser must return a number of <em>pairs\nof a result and a final cursor</em>, so that we can tell how far it has\nprogressed.</p>\n<p>This leads us to the following type definition:</p>\n<pre><code>type &#39;a parser =\n  cursor -&gt; (&#39;a * cursor) NonDet.m</code></pre>\n\n<p>Thus, a parser is a function which, when applied to an initial cursor,\nconstructs a nondeterministic computation which, when executed, produces a\nnumber of pairs of a result and a final cursor.</p>\n<p>Now, what is a cursor? It turns out that we need only one operation on\ncursors, namely reading the character that follows the cursor, if there is\none. This operation takes a cursor and returns either a pair <code>(c, cursor)</code> of\na character and a new cursor (which points one character further than the\noriginal cursor) or nothing (which means that the end of the input stream has\nbeen reached).</p>\n<p>This remark implies that a cursor <em>is</em> a sequence of characters: indeed, a\nsequence, as provided by the module <code>Seq</code>, is precisely a representation of\nsequences that offers just one way of observing a sequence, by demanding its\nfirst element.</p>\n<pre><code>type token =\n  char\ntype cursor =\n  token Seq.t</code></pre>\n\n<p>For simplicity, we assume that the input is a sequence of characters. More\ngenerally, it would be possible to define parsers that accept sequences of\n<strong>tokens</strong>, where the type of tokens is chosen by the user.</p>\n<h2 id=\"Executing-a-Parser\">Executing a Parser</h2>\n\n<p>How does one run a parser <code>p</code>?\nFirst, the input string <code>input</code> must be converted to a sequence\nof characters, therefore, a cursor.\nApplying the parser <code>p</code> to this initial cursor\nyields a computation in the <code>NonDet</code> monad.\nRunning this computation,\nby applying <code>NonDet.sols</code>,\nyields a sequence of pairs of a result and a final cursor.</p>\n<p>Assuming that we are not interested in the final cursors,\nwe discard them, by applying <code>Seq.map fst</code>.\nThis yields a sequence of results.\n(If the parser <code>p</code> has been constructed in such a way that it can\nsucceed only at the end of the input stream,\nthen every final cursor must be an empty sequence of characters,\nso no information is lost by discarding it.)</p>\n<p>The code for executing a parser is as follows:</p>\n<pre><code>let run (p : &#39;a parser) (input : string) : &#39;a Seq.t =\n  input\n  |&gt; Seq.of_string\n  |&gt; p\n  |&gt; NonDet.sols\n  |&gt; Seq.map fst</code></pre>\n\n<p>Implementing <code>run</code> could have been the first question of this exercise. We\nprefer to give it and start on a sound basis. The function <code>run</code> is used by\nthe automatic grader: if your code does not behave as expected, you will see\nan error message where <code>run</code> appears.</p>\n<h2 id=\"The-Parser-Monad\">The Parser Monad</h2>\n\n<p>In short, a parser is a nondeterministic computation that maintains a current\nstate, namely, the current cursor.</p>\n<p>Because a parser is a computation, it should not come as a surprise that\n<strong>parsers form a monad</strong>. That is, the type <code>&#39;a parser</code> can be equipped with\nthe basic combinators <code>return</code>, <code>&gt;&gt;=</code>. In fact, all of the\nconstructor functions offered by the nondeterminism monad can be lifted up to\nthe level of the parser monad. Parsers offer the following API:</p>\n<pre><code>  (* Type. *)\n  type &#39;a parser\n\n  (* Observation function. *)\n  val run: &#39;a parser -&gt; string -&gt; &#39;a Seq.t\n\n  (* Constructor functions. (The Monad API.) *)\n  val return: &#39;a -&gt; &#39;a parser\n  val (&gt;&gt;=): &#39;a parser -&gt; (&#39;a -&gt; &#39;b parser) -&gt; &#39;b parser\n\n  (* Constructor functions. (The Applicative Functor API.) *)\n  val map: (&#39;a -&gt; &#39;b) -&gt; &#39;a parser -&gt; &#39;b parser\n  val (&lt;&amp;&gt;): &#39;a parser -&gt; &#39;b parser -&gt; (&#39;a * &#39;b) parser\n  val (&gt;&gt;): &#39;a parser -&gt; &#39;b parser -&gt; &#39;b parser\n  val (&lt;&lt;): &#39;a parser -&gt; &#39;b parser -&gt; &#39;a parser\n\n  (* Constructor functions. (The Nondeterminism API.) *)\n  val fail: &#39;a parser\n  val choose: &#39;a parser -&gt; &#39;a parser -&gt; &#39;a parser\n  val at_most_once: &#39;a parser -&gt; &#39;a parser\n\n  (* Constructor functions. (The Parser API.) *)\n  val any: token parser\n  val eof: unit parser\n  val char: token -&gt; token parser</code></pre>\n\n<p>The above constructor functions are also known as <strong>parser combinators</strong>.</p>\n<p>The first group of combinators form the <em>Monad</em> API. The meaning of each\ncombinator can be briefly described as follows:</p>\n<ul><li><p>The parser <code>return x</code> consumes no input (that is, it does not move the\n current cursor) and returns exactly one result, namely <code>x</code>.</p>\n</li><li><p>The parser <code>p &gt;&gt;= q</code> is the sequential composition of <code>p</code> and <code>q</code>. The\n parser <code>p</code> is executed first. If (and every time) <code>p</code> produces a result <code>x</code>\n and advances the current cursor, the parser <code>q x</code> is executed, thereby\n producing a final result and further advancing the cursor.</p>\n</li></ul>\n\n<p>The next group of combinators form the <em>Applicative Functor</em> API. These\ncombinators can in fact be implemented in terms of <code>return</code> and <code>&gt;&gt;=</code>.\n(In other words, &quot;every monad is an applicative functor&quot;.)</p>\n<ul><li><p>The parser <code>map f p</code> works like <code>p</code>. In addition, the function <code>f</code> is used\n to transform every result produced by <code>p</code>.</p>\n</li><li><p>The combinators <code>&lt;&amp;&gt;</code>, <code>&gt;&gt;</code>, and <code>&lt;&lt;</code> are special cases of the\n sequential composition combinator <code>&gt;&gt;=</code>. It is not difficult to guess,\n based on their types, how they are supposed to behave.</p>\n</li></ul>\n\n<p>The following group form the <em>Nondeterminism</em> API. These combinators make\nsense in a setting where a computation can produce zero, one, or more results.</p>\n<ul><li><p>The parser <code>fail</code> always fails.</p>\n</li><li><p>The parser <code>choose p q</code> represents an alternative between the parsers <code>p</code>\n and <code>q</code>. The sequence of result/cursor pairs that it produces is the\n concatenation of the sequences produced by <code>p</code> and <code>q</code> separately.</p>\n</li><li><p>The parser <code>at_most_once p</code> works like <code>p</code>, but produces at most one result.\n Thus, if <code>p</code> fails, then <code>at_most_once p</code> fails, too.\n If <code>p</code> produces a result, then <code>at_most_once p</code> produces this result, too,\n and commits to it: any further results that <code>p</code> could produce are ignored.</p>\n</li></ul>\n\n<p>The last group of combinators are specific of parsers; they form the <em>Parser</em> API.</p>\n<ul><li><p>The parser <code>any</code> returns the next character (that is, the character at the\n current cursor) and consumes this character (by advancing the cursor). If\n the cursor is at the end of the input stream already, then <code>any</code> fails.</p>\n</li><li><p>The parser <code>eof</code> does not move the cursor. If the cursor is at the end of the\n input stream, then it returns <code>()</code>. Otherwise, it fails.</p>\n</li><li><p>The parser <code>char c</code> tests whether the next character is the character <code>c</code>.\n If so, it consumes this character (by advancing the cursor). Otherwise, it\n fails.</p>\n</li></ul>\n\n<p><strong>Question 1.</strong> Implement all of the constructor functions listed above.</p>\n<h2 id=\"Recursion\">Recursion</h2>\n\n<p>A <em>recursive</em> parser is a parser whose definition refers to itself. In other\nwords, since a parser is a function of a cursor to a nondeterministic\ncomputation, a recursive parser is just a recursive function.</p>\n<p>Recursive parsers are extremely common and useful. One must be careful,\nthough, to ensure termination. If a parser <code>p</code> applied to a certain cursor\ncauses a recursive call to <code>p</code> <em>at the very same cursor</em>, then the program\nwill not terminate (or will terminate abruptly by exhausting the space\nallotted to the stack). In technical speak, <strong>left recursion is forbidden</strong>. A\ncycle of recursive calls is permitted only if, somewhere along the cycle, the\ncurrent cursor is advanced.</p>\n<p>As an example of a valid recursive definition, we now wish to define the\nparser combinators <code>star</code> and <code>plus</code>.</p>\n<p>The parser <code>star p</code> accepts the concatenation of <em>any number</em> of strings\naccepted by the parser <code>p</code>. The parser <code>plus p</code> accepts the concatenation of\n<em>any nonzero</em> number of strings accepted by the parser <code>p</code>.</p>\n<p>As their names suggest, these combinators are analogous to the iteration\nconstructs <code>p*</code> and <code>p+</code> that are standard in regular expressions. However,\nthe parsers <code>star p</code> and <code>plus p</code> do <em>not</em> have &quot;longest-match&quot; semantics:\nthey accept <em>any</em> number of repetitions. Thus, they will often succeed in\n<em>more than one</em> way.</p>\n<p>In the definition of <code>star p</code> and <code>plus p</code>, it is permitted to assume that the\nparser <code>p</code> does <em>not</em> accept the empty string. In other words, the parser <code>p</code>\n<em>must</em> consume a nonempty fragment of the input. In other words still, it\n<em>must</em> advance the cursor. This guarantees that the (mutual) recursion in the\ndefinitions of <code>star</code> and <code>plus</code> is well-founded.</p>\n<p>In the following question, we use <code>star</code>, <code>plus</code>, and other parser combinators\nin order to build parsers that recognize (decimal) digits and numbers. A\n<strong>digit</strong> is a character in the range <code>&#39;0&#39;..&#39;9&#39;</code>. A <strong>number</strong> is a nonempty\nsequence of digits.</p>\n<p><strong>Question 2.</strong> Define the parser combinators <code>star</code> and <code>plus</code>, whose type is\n<code>&#39;a parser -&gt; &#39;a list parser</code>. Define a parser <code>digit</code> of type <code>int parser</code>\nthat recognizes a digit and returns its value as an integer in the range\n<code>0..9</code>. Define a parser <code>number_lax</code> of type <code>int parser</code> that recognizes a\ndigit sequence <em>of arbitrary nonzero length</em> and returns its interpretation as\nan integer. Define a parser <code>number</code> of type <code>int parser</code> that recognizes a\nnonempty digit sequence <em>of maximal length</em> and returns its interpretation as\nan integer.</p>\n<h2 id=\"Parsing-Arithmetic-Expressions\">Parsing Arithmetic Expressions</h2>\n\n<p>In the last part of this exercise, we would like to parse and evaluate\narithmetic expressions. We begin with a very simple language where only\ninteger literals, addition, and subtraction are permitted (Question 3).\nThen, we add multiplication, division, and the ability to enclose a\nsubexpression within parentheses (Question 4).</p>\n<p>In the following, <code>&#39;a op</code> is an abbreviation for the type of a binary\noperation whose operands and result have type <code>&#39;a</code>:</p>\n<pre><code>type &#39;a op =\n  &#39;a -&gt; &#39;a -&gt; &#39;a</code></pre>\n\n<p>The following three unnumbered questions are not explicitly graded.\nQuestion 3, which relies on them, is graded, so you will receive\nfeedback after you complete Question 3.</p>\n<p><strong>Question.</strong> Define a parser <code>additive_op</code> of type <code>int op\nparser</code> that recognizes one of the characters <code>&#39;+&#39;</code> or <code>&#39;-&#39;</code> and\ninterprets it as the corresponding operation on integers.</p>\n<p><strong>Question.</strong> Define a parser <code>multiplicative_op</code> of type <code>int op\nparser</code> that recognizes one of the characters <code>&#39;*&#39;</code> or <code>&#39;/&#39;</code> and\ninterprets it as the corresponding operation on integers.</p>\n<p><strong>Question.</strong> Define a parser combinator <code>chainl1</code> of type\n<code>&#39;a parser -&gt; &#39;a op parser -&gt; &#39;a parser</code> such that the parser\n<code>chainl1 p op</code> recognizes a nonempty sequence of <code>p</code>&#39;s,\nseparated with <code>op</code>&#39;s,\nand interprets it as a left-parenthesized chain of applications\nof operators to values.</p>\n<p><strong>Question 3.</strong> Define a parser <code>sum</code> of type <code>int parser</code> that recognizes and\nevaluates a <strong>sum</strong>, that is, a nonempty sequence of numbers, separated by\nadditive operators. For instance, the string <code>&quot;24-12-12&quot;</code> should be evaluated\nto the single integer result <code>0</code>.</p>\n<p>We now wish to introduce the multiplicative operators as well as the ability\nto enclose a subexpression within parentheses. In other words, we would like\nto parse the language described by the following <strong>context-free grammar</strong>:</p>\n<pre><code>  expr ::= number\n         | expr additive_op expr\n         | expr multiplicative_op expr\n         | &#39;(&#39; expr &#39;)&#39;</code></pre>\n\n<p>Unfortunately, this grammar cannot directly be used as a guide in the\ndefinition of a parser. Indeed, it exhibits several flaws. To begin with, it\nis ambiguous: it does not indicate that every operator should be considered\nleft-associative, nor does it indicate that multiplicative operators have\ngreater priority than additive operators. Furthermore, it is left-recursive:\nseveral right-hand sides in the definition of <code>expr</code> begin with <code>expr</code> itself.\nA parser whose structure is modeled directly after this grammar would diverge.</p>\n<p>In order to work around these problems, a common solution is to use a slightly\nmore complex grammar, where three syntactic categories are distinguished,\nnamely <strong>atoms</strong>, <strong>factors</strong>, and <strong>terms</strong>:</p>\n<pre><code>  atom   ::= number\n           | &#39;(&#39; term &#39;)&#39;\n  factor ::= atom ( additive_op atom )*\n  term   ::= factor ( multiplicative_op factor )*</code></pre>\n\n<p>This grammar can be transcribed in English as follows:</p>\n<ul><li><p>An <strong>atom</strong> is either a number or a term enclosed in parentheses.</p>\n</li><li><p>A <strong>factor</strong> is a nonempty sequence of atoms, separated with additive operators.</p>\n</li><li><p>A <strong>term</strong> is a nonempty sequence of factors, separated with multiplicative operators.</p>\n</li></ul>\n\n<p>This grammar is still recursive, because <code>term</code> depends on <code>factor</code> which\ndepends on <code>atom</code> which depends on <code>term</code>. However, it is not left-recursive:\nalong this cycle, at least one input symbol (namely, an opening parenthesis)\nmust be consumed.</p>\n<p><strong>Question 4.</strong> Define a parser <code>term</code> of type <code>int parser</code> that recognizes\nand evaluates a <strong>term</strong>, as defined by the above grammar. For instance, the\nstring <code>&quot;49-12*(2+2)&quot;</code> should be evaluated to the single integer result <code>1</code>.</p>\n<p><em>Hint.</em> One approach is to define <code>atom</code>, <code>factor</code> and <code>term</code> as three\nmutually recursive functions. An alternative approach is to use the parser\ncombinator <code>fix</code>, whose type is <code>(&#39;a parser -&gt; &#39;a parser) -&gt; &#39;a parser</code>,\nand whose definition is given to you.</p>\n<h2 id=\"Notes\">Notes</h2>\n\n<p>The parser monad, and parser combinators, are often considered an attractive\napproach to parsing, for several reasons:</p>\n<ul><li><p>Because parsers are ordinary functions, they are <strong>notationally\n lightweight</strong>. In particular, because recursive and mutually recursive\n parsers can be easily defined, <strong>a grammar can be directly transcribed as a\n parser</strong> of identical structure.</p>\n</li><li><p>Because parsers are ordinary functions, it is easy to define highly\n parameterized, <strong>highly reusable</strong> parser combinators, such as <code>star</code>,\n <code>plus</code>, and <code>chainl1</code> in this exercise.</p>\n</li></ul>\n\n<p><em>Note.</em> The first argument above works better in Haskell than in OCaml. In\nOCaml, the right-hand side of a recursive definition must be a syntactic\nfunction <code>fun ...</code> or a lazy thunk <code>lazy ...</code>, which makes things more\nverbose: unpleasant eta-expansions are often required. Also, in OCaml,\nexplicit uses of the <code>delay</code> combinator may be required, whereas in Haskell,\nevery computation is suspended by default.</p>\n<p>That said, parser combinators, as presented here, also have several deep\nlimitations:</p>\n<ul><li><p>They <strong>do not support left recursion</strong>, which causes an infinite loop.</p>\n</li><li><p>They <strong>do not guarantee unambiguity</strong>. In other words, it can be very\n difficult to convince oneself, by inspection of the code, that a parser\n can produce at most one result.</p>\n</li><li><p>They <strong>do not guarantee linear time complexity</strong>. This is related to\n the previous point: because a parser is a nondeterministic computation,\n its execution involves backtracking. In degenerate cases, it\n can require <strong>exponential time</strong> in the length of the input.</p>\n</li><li><p>Although parser combinators do guarantee linear space complexity,\n in practice,\n <strong>their space requirement can be very large</strong>.\n This is again due to nondeterminism:\n the data structures that are required in order to support backtracking,\n known as <em>choice points</em>,\n tend to accumulate\n even when they are not needed,\n because it is not statically known which computations may or may not\n produce more than one result.\n Explicit uses of the combinator <code>at_most_once</code> can remedy this to some extent,\n but placing them correctly requires expertise and effort.</p>\n</li></ul>\n\n<p>It is possible to try and remedy some of the above limitations by performing\naggressive <em>memoization</em>, as suggested in the paper\n<a href=\"https://ir.cwi.nl/pub/25145/25145.pdf\" target=\"_blank\" rel=\"noopener noreferrer\">Practical, general parser combinators</a>\nby Izmaylova, Afroozeh and van der Storm (2016). This is technically quite\nimpressive, but also quite complex, and still does not offer guaranteed\nunambiguity.</p>\n<p>We wrote above that &quot;a parser is a nondeterministic computation that maintains\na current state, namely, the current cursor&quot;. In fact, our Parser monad can be\nviewed as an application of the\n<a href=\"https://en.wikibooks.org/wiki/Haskell/Monad_transformers\" target=\"_blank\" rel=\"noopener noreferrer\">State monad transformer</a>\nto the nondeterminism monad,\nextended with parser-specific operations such as <code>any</code> and <code>eof</code>.\nWe could have taken advantage of this remark to make our code more\nmodular and more abstract. For the sake of simplicity,\nwe preferred to keep it more concrete.</p>\n<p>In summary, we have presented parser combinators because they constitute <strong>a\ngood programming exercise</strong> and a nice illustration of <strong>nondeterministic\nprogramming in the presence of state</strong>. That said, as a parsing technique,\nthey have problematic limitations. If you wish to build a parser for a\nspecific language, we recommend looking into other parsing techniques, such as\nLR(1) or SGLR, depending on your specific needs. We also recommend using an\nexisting <strong>parser generator</strong> instead of writing your own parsing code, as a\nmature dedicated tool can offer a range of services that is difficult to\nmatch.</p>\n"
      ]
    ],
    "prepare": "ctO2f4oAbE0FQMhy164mmjsLTUE1FBQUZBl1GBjlg1UjslppWGiWUygkxKGpcrhsnTzZ1zgagfbtUsQ1un++tldeDkoqHYtG6P/nhI9N+4cdQg6CmLg1tTFYGcVP9S7N+uHSccAdUbjF1XWQCzJGbqvBuzmMRFHdfA6Mbxe4cCCmnIubbV4/IfFAr6oPKJm/ZABNGBEEGUpyWUUVH+4xmivfDiIRJ4Fk1i8thqyefC3FNNxpJm4vqhs4jUj7R2en+DYCDWJmnUX+cDCu6A1/dysO95eBgirWPFV+yR+R0MlMzd4XlEdWqJZ622NHOE8iex8vDdl6Pfz9AQy2ndje1bC06vmlReEUxUCfSBYb8Ks8SURMHA1Z37Z3Q6UYh3TIYb/IFic5joMjLKiacLW90IF5jmF8Krva7kaZE+JxjPARN/wRLFyKI+Pl4fHBVGS5NAjVAxD8U0RfVQmYR2A77Vf0i0aZToe95mQ6ll6pSKeg7JgG699Va+RQZxyL8qRegsX3wKUUqB36QLwIFy8ZvCIVD5QRQUxRYBBGXETopt5er9EcVTm0MTxlu+G8l3M5oDSU4jNnfvLPFwUex7rXq9IjX/EBXd6Y74pyhYRYNasoQhs/p0NRqDoVFs6C9UHLDt8+cZZPTuDQ3XvDTi2IxvOBuznBCkytdEl3mI7OsiLcjJahuBmwWxs+r9cX3IitYl9UHoEDGRhxEEU1EKPxmivfFTkISss41i8ub4PefnyEOYwVYiLvxvF4/FDj+NbbGzUKWGJHmkaBiyas6AB9d7kObp+Ntkn7F/UWjEKRIxRAzcv95l14/sAlOcNPMRTf9d4KFYEDT+W9FRbAnhPvFeO0ivntFLEJ7lDZBk5uj3leTUlPX/2+WDlQSUYQhLqBEZBBPR9/8kd6P3ftbe372JBojycuKuyoxUXZFrMupehWPpJLY64HCcilYt3EAGTnNoq0TdzfU0E74o0YQwE76Ai+8ufYTleq5mpnlo6hHLL+7IRG5QtVc+Q8B1XL5bxXtgq3uKpUtQzLQNQBW/LZgWNBTUoNGXwWJlMRHU8vgM68fRIlVWiF2XNhu+ncbbM5oDTXMClova+6BhxRvzi0aoZ7Roc7SNVY5PRigKhvZPIcCdFP9aYSqG5UXZkCinKMGM8+gcBIVenEPTqJTmYJbvSIzWnBCoWweQsModrTcCjmmg0wh8foCYsAr96YMZXPYlFNTFRVS/oDEBEVELyx8zelQTV1YNZBWX7suLiehnDE32UuIDuvbqJXlBHkYtPj+DYCUWIQ65rJvHbDmUo9ajc9/UaBtkGdPFUWjEKRTMlMt2uclEdWqNAlZcMt45+wdID1SxFTRvC9QFK8nhelP0O0ivntFLEJfAalGoZp53/8FQpHVB9RVjQBGBVIfrH7E0wB1RAljo1jO3zts+OpINhl9mg8JrO7rka3UKJ9obxL3UoR4mvGChylMvmQQnmnKRj2RtH9GO6l4o0YQwFb6CeS/qi2UTndlDQelldoSJSaotFt5QtVv46NLd+Fi4Qkfg43lfUUqB36QLwIFy8ZgWMnA5FUGUEmQoARWVXsfJwbbUFnEobXF7Atu+T/vOMfoDPV4nder4+xXdMRwWvXf9IuKFF7EIZNiLwagYlA+3o0TwVPp0NRdXlBVZBCnXGEFcKOs4wPFumQNDrPTlxkbqjWu9+BCoWwwEkM71q5qXGZzcftuBSoVYtYr/IM3IGjYloTZ6EZGR/wEBEVELzL6iXwQTUN0NtQNQ46g3fqhi7XP0gVYiL7vKE9//423MPtCi6FLGJElkyHwibtn5AL9TADjUbSgpPk16IW9QmF0YQBzhzh5RwTdwNoOgpJMQrnt2uFB2VORavvTU+Ah+TlP4a37vmbU4IJoA0FGlMf7uEoCAMLEUxZUG/+EQdQbvCJ+0xVPU6Kjkcm3OqgdaquK1Qg7/V81rv7xVbQVfJ7/fNC4AIFK/XIIYyl4bjEAGTnHp4ZZ1GmU0pdVVOUE2QI6EC0jqiQTo04yiwxll27RxGgcY6Gm9kvbqEPHcjZoewftd83wOU4xACLCuN7PH8ZvSYVTQNXZ9wNOk/4U6DvfNIebQ/dBjCPXjgSu+ncbfozrj4BPTAzrOqqGN/Cx8rXs8F7UB5tVh6HmLxhr1pANas0ZJVPn0/RiTpCWYxG9WiCQMn0ughGWPqKNECHAEhEtfP1bU0FRFDfwAMDi1q+tWablwDsbFGoQMkAdopWMYu/I6E2AF61XTNwEBEVEOjynHulQXQ0JwIRO7mxuOfbtyWB3s1f0XKMcaML9VTpZs8tBmxCBSwZkQq4tSjbmUdvd8hI/TSVaCep2QZCwW7RIxRAzgOrlAFZfNB53wxDPBvatciWF162UKy/Ap7J7MG61430zaT9V3R+ilDrAFNh7uE7A5ZMQ9/YW7pQWFMQdLmI0PtSFkV5jkcmO4idd0KzZMR5jid71v0seo8ZQr2fpqtM2U24Y6vPI+Pl4fHBVGS5NAjVGheMH4VqAR0QGtI7y9C1zajER6+zlDNflpNhGfep/+gG5QtVgOUZDdHLkv1krwrJg461zpzLQLxUF6+QvWNMUjYRGR9Z+RARFWqEpt5er9F6VQOUESBhw4SobesmmTSZYU/nfvK6Xc9RxyOXwF5jV6h2XMcYi4QyqvhvZPJgRJUrp3Q3ey6VWZgCozPWDsKUrtwP04CV3ynHBloIquaNkl0PREGwdA53oILAsWyjzg4vuFi/C1ITr5/GKJWtJ5VyTBEZGR9cXoFUXuz66yimDiQBJ2tMN7yhf4Ohw7eEPwkVSXLverQLjUPy+J4nBi6FBSxQol8KxXa/iFN9fHFJkEbVr/GzPBoY8EKMCIRAzcvp9RsVcNBt+NsGMRbmwMCrRxELF4W9IpXFnhPvFeO0ivntFLEJn5PgHTohj3V8HUlqX/2KGWFqHRVIfrHINvRuPVV5jkcm3Ki5bLW92IplyDh5M0b7v/aIGKJmoJRxN5I2JlSGRdnfOLyMADn61VOaTdGmU4BgGkGMCwEn6B8IdN4QTofjlFUe6AB8DPvamxQRpF/0hOxKVxzpnfVxds43cPdUfVujQPhHUnqZvnpVTR6USkRQJkFFUBDput6Ah6JAVSzIXmIj6fncbbM58XuSN7leqr36DJoAcjeZaQ1hA/suOvpL705frYRSI0FoCdQ+5PcRsH9EFtJC/zOETYX+bwFPGfLQ2yS1Am6Idv806FnBDFSwdERM5ZL2cC3myJbtbBjoEhtCcQ2+3MTPYlFNTFoYTVx6EE/GGLD9nGLwSTRVNgILOkKsuLieqnCv426mYon8evFSomr7Kg3bQ8YCUTZCllf8cHas6Fo99ThAo9aJfkjdZAY4kELn01xTzcK9iEcPec9lNtk/MU8fdI7ERxFORKydTRWJmY8l3OLOybCtU3AJloOfEUVSj3V8QRFM06UZZz92DmdQr38IOewBPRM6/ppjUx4wdeaJCtpb/HJr4b3quFLUHKdzzuNPOpc10ojLBxTg1rCJDWya4EOYQtnbXLEoWBqVTgpq7UjWkaD2Q6roiT9ji9IdR44c6Y/L8AYYwK/AQYTG8qhlz0HWwvokapyCD3xEUmW1vm1AGQV3Vo/WLoBFXVWgwx2ka5RwEDKWF8loarGcsvor6XC+4j/epI8tEJkEezfXlAkhZ6QjEJtLjvAsrM2UTs6oTwkFp2JRbyl1WxlQkCLHDcWOsJh+Vb7Z3iXTGiADqfOIn5zBS94rdQAJogbOsXPizhmwbEH8Rc6Abl6QMZ39LlEMA9JOXEsyEBt1OwPxnGa8EX6VZgxRICaxaujcxzzIY1YfYjaAxvF4jUTtYtObTn5CV7N3kVmMw/XH6ABtbHEq/RnUdBLg0pYWzpi42tlOmwrwzQBYqIRk1JY1MQ3lsY8FFMZ3WOmvGUnB7xfz3ODO9q7/FPBHmlDxDUIs7ftpQQoMVkBXWCUfERUQr37J239W3A2rjkVfUx3tq+bf1IElyH574rv/hBGKRr2gyuhRYlESJlPVCgT34bjEAGOm1UOLTd0nHbcuEETYBNBunBXJyai2UR+e9Xwx6Aw8YsDp7IoM5WxVgbtDCMn4nfZpbsWXaa62d5yIDa1YQnnYtSxOAloBSkZ2PFNUR6DhfJsbfoRhGnO3Xmpbu4ehvLZt9G3+VWNnfvK6NxlRfi7XeA2zUBQoV164mLBag1kOZKYgBdZP7PhBdH9YUgYWlH0NDcXTaZE1FqiQ1zf2DGUBs0fIapXOR9XddA5oxdrOcDjmmJ0/eknoSM5Dao6CKcz9YoIYDkJ1S9wwUkg0RPCzyXurCHI0YKAMDy8thqyex7CC22lmN7CqxrIQ/lXuZ1LaFycNHjJupH+Hiyas6AB9znVOiBmBhoepZR6Z76LZ+d2AlwTc6A2TqJFf+IQKYl7rv28BRtgNF4itCBaMndje1b4S9PysQP6GoROlSBooddc8QUVGEWkRXG/a1/R2c37J24QO+RQl96Ac3N0Mi+fsYxstlTt31vPqdQjWRb2h/atE1EtSKkXISNDh4faRVGScJQ0QHZ0fAq9WVR0YQwFvoRO0/LLQB/qt9X2qiUdeQ2D+7IQSjFsQv+MMTMTL9aRzzZq3uKoXa9T0F3hNDH83wClSG5/DGR1ZYR2QGRCbvYZxeQRqXGCIC8AefParbbhboDPVMTA/uaC6GZ6YeyeFblIeHFF/U16YiuEsohQAO4IKLqU+8aE3gH9R+aJx9SKMSwrmtcA0XqyQ4X+DAiQFqee1oRLIRFrwfpsMdxaLrHmvgsKtbFmlC1lVcAsCMZ+uYpIMAFlZY/R6GWpVRP788W7fEXEUIggk1i7suLjluWn2NMMiJ8mvj3IQ/EHi4cLDQycRUSs3lETCtTqs7Qk9qDh+/RjIcByxPBsZ8lnRKIkvt2ucyAwCqJRo2gIWMUCidJKEEdcCQ+zwUlnO7xfgNLOBivqsFPpJ/zvfSBZh/+AiQQhDXE/MTSpQQ6VWr4XIMa2JNForzBAbKP8hbPrpIIIliTFJ1rv7xQTZUrkzobtW1pIMSDvGCdWoKbiWRTCyIpCVRgzmSepeFBaYWJE/oUDWjrDfTo+dlH6b6lcnBe35i2AD5V5VefRQTNuLkqRetcKQ6vpUtQyQQP9HWn7MtSZBEGYRGR9ZYRxRY/WgvZwbr5BaGSX0Cmoha4enqeZ85TTANnZnrO4nCwVFx/DPplpj26g7VM9Ljusme2NFZLtaGNxE6LMFcH/aFs6C9SKEQM7PqwMKR3aQ2iS2Gi5GueH1mQyPCjefjUl0pJaGcE0ugsCtm/HnSNhTal6BP2z9MQRNGVcYWkUtEEV+EOzf6iaqAy6aYNs41i7suPCltWXEZsEtN8fbd+k49F374caeQy/XBTFZp9fJxmCanER9xDQ4pAvSgpKd1RwEyULDZc1VkhfrlA/Edgll0xBDGl8fdI7ERxF1UKywGBa2nd7k2PbAiq88FP6HmpygCUIcj0EuCBgAEUg1GSkZQkBTe+SRObxA05Z5/Ax63OLedar/YYkhpSlzWOv7xVaZE+JxjPAW4lpEIlTPRM4lBKqgADCc1TXGMtbmJ4RkB6+REZF86BT+9eHQDF4pyDRnyUcSOIypjcA4mUh0v+gEZvPL8u6hggqWtuIJrAzDD+sIDH83wGMMREpZVAtZ1oAWVBClct5dbEFpXGDBXiQfu3Gcgt95oDSUMnYzfrHrEx/EczfXeUJpA9o7XZ1Fnutnq2FUI4JgCMABp3sRb8sVGdZCzWbWQMPTdgMAWbnFYHeTHDEOa4zIp90IRTbwwEkMltqNriD8mxuwuEz0CYsAr9A13LCuYph4CFRLGUlzEEFHXajc7iffAHMMNJMWPTb6uOvbhjjRZdBaJTrhd4V4yEyy+MLvBmZgHHNs7Aq5tyb9lCw9dyFO/UaBcRDk1AY+jBXUItIBlw0c9RpWfgVh2d6PZ5ifr10ADdJKQ3n9GQTAzIfjZLPLyaaaX4cO7mqdNRYg7rUiCQ6zER9ZGW9QEVNRdKS2+4cB46xr8oYcL3mhcLSsLtRRp8xoKbujfBK1E2/z6tNCZ/A3J9XFTsulPvOERS7iPAq0GdHIC1Ep4o0YQwE76EDMyajVFkPa6WBblosgD4vmod9WkFcUa3lCAxzppbYcfb0QuM/CcFqSQO5NRSjVtWMRHpNVTFw1LRBTTBDpqOIer9EcVWD0F7Bha3irvKZ9oHD2LSYoqrehXhk3xzTCeEJ/VoI6V2VY701pxcBJKv1pGspA8eMvelF0FuEE9WPKBJrNsZUBPLmQNDqTTmEmsbKIiDrBTVT5fBgA7ZmLcHDznIvta/H5XMhTe96CMJm/LQQVGBF7QWR/EEZ2W4v5nHLwQX9+Lwg4MSGHuLiehnDENN1bLmf8eOZ4x/3/VwrbFygHUSRRml41w8usoldvw85ApAfVb6enPAF3zR+RY1UNisvvzRs3qKstRskPOlHQjx7ECtR4F3a/BACJlYem4LPWiuGGFLEJ7pmaHBYe/v5mFB9JEUxZXj9NEVMYtO7B2ZBBPVV55FdpNbDdfKbzIJ93/Hc81rKxxS71E3NgluhX3EMTL/WGXd0lLeaLRDGoNEeUAZ7mAa/qAFvMTwFonlDMyajZA/qg/Hkf6pwcE4vgosIJn9hav+RNTIyL8vBkcwrYe3VYgFqOQP9HWCnQvmYAGQV3Vo/7Ljl4FRvpprIer5khAWCYFmpiarzcdfhooCfU3CJnwfr6VgQDx8GXrQMjTk67CxYMnPQneZ9vZPJoTs9K/0MSdiEFQhpH9XGEBwqHaZk3GPb43WrGGiRIv4CAp6PPCoj5wEBS7Y+1byedkxegbFGoWxtGtl64NqP/YlFNFoF+V/QgRUVQEOTCnDrfQTV4YKp+1me9arfqhjW1121vNm4vj3oOwBH8Z2ObDyNWUSsE6/qIwnmspUEyryEBllbIgpKd06BF8QeF1YQElx7h9os+g4xlOcNPMU8fwM3EP2JjGfyLApaMnd35P4uIir88WqQF7pyrSFAg9K9pQQpCVR/+WCV1Q6VEd+iI44tI1QAny/dpNbPhcLWjYZBcjmFJ1rv7xVaZE4Z8krwCYU2RK/HQTxzjKvTIVGunBQ0QHYSaU3sgVVOABcJilAW0x0DCM60cyyAeypw/SLO97NQHl/5VeOUOBIzEnNhctgq3uKpUbFiYQO5NRSjVtTBBCQVDXFwNJU9RQVbg9gsGsEFSGnO3Xmxtu3Xrbf2q7yGY4nxzfrT5FwVCrSqAblJzUBhlW1JOxaRaeYQAZPIbGd2P8rQ4qHxUXgQXpj3EAcSUvZ9BQajE4XS2TlxO6aD1nl0IXozwcpJMiYPPxDiylg4auFLpQM1VfAlWKIrvMpAKDUV1S8NwEBEVELyxyWqsAGdRMctIO7m/hb7qhiCFZd1jLTXvcr9N/9T/Yg4uET5CWjtfuArJrDvg6FMuq7JOyQLBvVGe4VV0lUKLIxMBzfzh5UFCqMl3OcNPMQfqqx7MThEGChO9TUnJnhfgMaDU9amgQPQ87lCfSBZhj3VuBo5CEUEZXj92DoV8aLyGWPUP0/Vx5kNmPvS//aq8IMQl/Hc83vmiekaRGKIz70ho1kN4DFyKAvP34biIRTDnIpqTAhTpB0plG60CQtRtmRS0kbPQRoHclDhekAhoB4PpocQSnER0xKRXTIfK8u9cuuH3uKpUcUmHA3NIH8fMvjNJREp1BmMZ+RARFRDlvZohd9FnXWy0CDxtgY+cbbM5oDTI4plcwO36Ut1ex7rXq9IjA/F7EMBKpL6VeYQAZPJoEwUd8qhUqDQNGs5PzCKJXuH+a2BPFumQNDqTDH9Hs+PN6EeTT9Hdc5NMl1KOrR3mzcftwTf0CYtMaopWNYvkLp5ZTB/UGQNwFkAVX0Dxl8qqDiQBYNZB1iCve0iohn3FNN/jYmjfcr5Q/oGaAZ3bQ8ZEBCpQ85KJbWHH6AB9dyFOjEGCaBmt+QFTd9KRIxRAzcucjA/DdsBtOgVPPF0f5d4JAhEDT+W9HpyP6dri+0P2kfWGFLEJ7lCfSBZpyeAsQUkEGB9UBj/bX/sVtML7OexN3AF5z5tMN3LafYSt0x2o/H1r1qC7w6eZXKtu80gF2pI1Y5jtChyl4fyBTCWu1U0TGxbmW0UdWA8nQwE76EC0/enEDFfdyW2uypZ/SL4p5IkGk9JBhYgNTIyL8qR6taWRhr9UqB36QLwIFy8ZgWNBTQwQUFUm+RARFRCgsM6IcQohVW7DUiMHwKnpg195oDSU4jNnfvK6DZoFciyZq6x1A/F7EId6xaRax1FUZKAlDZUG8b1UeyAQVhhH9SuJUZqAa21OFqHZNDO3XTFSbq4J6ArICpbwxpoMoMrTi8jmzcexfV8pUIsIaBkY3NHtYloTZ6EZGR/wEFoURPv5nH0wEXE1NNtSYy7/w0jtvySMHwRaYiLvxqk4sket0w3mXBpCUWIQ65rJcHasnRJOdyFO/UaBekHP1o6TjEuJMh6AktqllEII/sAlOcNPMU8fdI8HDtgERrn9RReMycrz1ePDmfWtHP6HipXxBFMg8fB8DFcMXA5QMj9QERUZ9dLIOaYE+VUny6om1LOntPL8KI9//GV82+r7eF0ZG3dg/fRCMUNR0pfGDMqlMrSEGzTkMleYTcnZU0pdVVK2DsBe6E828ePQRobdiSxRlldoSPupo1USp9MVgP12AMC48u9ttgPXuPs2gUG6QLwIFy8ZrWMqA5JUGRQHQoARFRCgfM5er9FeFCzX2XNhu+ncbed5siqZOzNftuOsXgQAvnr+xG5jA/F7EIYL74RawMwUI+AcCcQZ6LNZdSgVTt/L9SuJUZqEhckPWfeZH8qTTmFBlNuNn5KuIRj8wEBB6M+DbTCb/sO6xRzdBIZNslU022Tx09oAQRpUFBR9HRpYH0T/oT+iTDBY02ZS4yW5x0Dje7iJOZ/n0yayufoSkBnqJwvmTmtPUW5ZuCGBaybZiVA6d8ULlp+Pb5Xk1osFk9K0Kfgv9cDcrQEWdhJp4xFPZQ4ft2eLDdULQbmjDpP+5svsP4uViq89U0F2l6DaGowh8vB8BpQUEUkRXG/ESEVVr+3OObhO26Ar7FdyNfirbNH8IMRPkm17IJ3txT3WRr2clroON/UUY/PJXtWp4eiFU7WaNBuQHY8wFLogAkOKGdVvmQe1juKGC9Sd9TRq76clSIHina/K5Uw0eYgNTIzOjLFqftbWg3JTtVeEF4YMF7bWsn6+TRsUGV21LFQRWkbgwg6bfABwHCbVDHMgb+mdsfd57ivUKnpgubmnUc/4eXbXboRmTFE8XvpL74QfqNFBKLt/FgU06OAFtDpQTwtHpX+EC2X+vZ5KFqvF3y7HByhGbxqLmA4T26rwoUlYoxDLr8ipkIq5fBTmTItBr66XMYq/LA2NDTtZGR9vWFBHU4vd8WzfAHMRYJw4Im4bg3znuGeINNIpMXK8ePILzFa60wzbSDdx3mZJk9fJxDCzpUg9eksO/QnJd5OWF/l1jDXUItxFiwecypF+g2Be2ZZP467axtyQDdgFF30vTQa1z2je0bCXirLsW4RFl9DxDV1d9Kt9TUl0WVB+UW/EUFgVfr7JOa9U0pYq7XVm3Kisdea81xF5pSlsI3uyfArRVPAuj4EW49t4JRDJWYzk4eiFST0nC90WQdHpBOgqG9TRPgl7lp837L8QNFXBlHkxlpgaSLObjNESvptVv31FD2rKm+BhhZqWhahUgU0AB4RBF8zXxWMfD6/DS/ZLFBBYR6Dhwx2qd5RqVSOODSAiafKc8fsk/m7UKCZnv3PqXhkQfWfXaj5jA/E6R2RYovZar1tAJu2oDgVH6ax4cW5QFw1Q9WqKBsKUsIQKHenD1WvGCydLqaDHp90VRFetf6gC71GHi63e92e0fRTnRshMa96EPY7pK6MITFAZW9peQkgHEOjynHyaQXp0YJIRNTH8g3zbhiOBZ1EfLTGqxrhZjUXsYNLpET5CJSwRl5q3rnv6pCw9dyEIj6jCc/Hx2BAWzpeYZdxUzhfnlBcXbNBkOgUG4pGrsY8XAcB3UO4yCEm35svdP4LVirX7Uq6Hp6TaSEQc7+AiCB9FX/1ZV7dfERUQfv3F4uxfWDxGw/dyNb0wdaX8VIokpHdlP0argVbOXqB5/a5L3E22Y/LTXhz8ML8IRGS7IpqDCxayU3/qVVCKD2p7lRPS/LuQGkegb8Qeloo/C0Sln2YC5VcMb3FNNa0La0Ftq1b8xvp3rCO6FOMYUi7+tDESA6hRBDMZ+UR3X/XifLsbflcw4luTVXMZu4mdv0B//8T2LGMmfrmrEZkUczeFdpshSpIjW1ULnutnq2FUJ+YhA2sP/4tQfDpYVgEMoWPNDt8+qNA1QqjE1Tr1CTE1xfDNu9+BCjevdRd4owymb8jg9qSGwBfo41MJfU64KczqN6IZTFBXGV5gQFk1Ua7d5XTlQXITYIdXNy8bbPnqw7CJ3cxbJiKbdOAR7/4s32ueEDZWHzJEm9f8cHasn9dvs8Q+lBjMb6ak0o5W/Qi4YdBOzeOwlAZFqIN51wdDMR7xs1eBFMBJW3n9GQOJ5tCh2Pi3irXhGLFPoBKfCkxg7fpiGENMGoAmMmkJQVAQqvyI+atT06AnjlJZ3KiqfKzp0gYlzWF83ri8xVXZUq2goPEQPpIaLVe7TsifMt3rCGenBQGVHZTcU4ldBV3KE2Rp7EDU/L8QD90tyHkb5EchHPv9ohQSnUhVhOx2G2iL6uUchNfPb3/+d9nLDaoIVTCYsnICGQ/DS6AXQoARFWToxZtehp6hGSSIXmJherPpveZl6WD2MCknxbn6CgFUx/DgdQoSRpU4EMsEoeUehhRnM0paBctIp31ZcWcVVZ1PpX4QA1bTtwgDPLmQNHzKTiAYvumRmQ8GClH6hUlKiIXNxHTdk2eXp/qa01hUsBsZNIvYYoUCTF6NFR9pWVRZVOux7TqwBGpAJZU1Ny87fujuxzzWZgQpJV8vxvE3jUPy3MLnF8ZDHnYQopqPqTGtnAAywnM2j6iPtmDqPAJTjAPDZhQOkIeczQFCbYJo+I1K2U7mqx8QDtQLUbDvDACJ7Nrz0qmJ8+CGFLEJiAWfDEQi73UiCQ5BHR/AUCo1VVo3ar7JOb9E0AA//Rpj3OLvq+zz1gFhpCos1rCu7iXRGfJCl0hW492RM/HUWMnz4g0U4WSeI9e+C1HyG49dEkzKDgFZblCHoqjVAFDBiDRqzpwaSLO97M1HmpsGaO1OC1nP8usmadL3e45btQzLFPINF8jXxWMOCloFUVpZIFgBQESgrgowapBpWWCIEHMcbbyqxrNz8XuVMjMoqaDnEItReieEf9JaTFE9U1V470Yfe1VOZL1dHtEWfeNRqGdQRhlHijHBQNS1aZMHVbfR2jbWHWJGbweH6AaPTVuefQpYpITAcHT5zgL8alCoScJAa6wZKIztLQZNBUUXGRN5O8sZV3ixzzelQTUFYMF42DzsaPnwtGWWPZRiK8nfcaV4poHo4dXiDHELUX5Q5UvJ6mvd7/R9eksO/Q+PhpTxF/UW6FnRU1ER/ZWeuooCew/f4P/PMRT9dN7rRxFXCfyKA5Ls8suf0qmX8Y+tFOlX7mPaGR5kzLV8BohYOmMREj92HB52sOXFNu2MMF6sk/Jb2+C6tP0rL19gzXJr4b3quFLUHKdzzuNPOpc10ojLBxTg1rCJDWya4EOYQtnbXLEoWBqVTgpq7UjWkai+R8nWjDhewAxoHerbiIQSm5sUabtECIzPofJlhNKRhvFWfATRB35HF8jBw7YRGQV3VlxZIFhRQV8prd6bh5RqF7zIGykhw28kqux56iqBMn2YfvK6EJwScizXb629Sod/ENRKoeApxIRUI+E/BctIp4xXqGtQFw9QkCLRDs3PqwtWGunRZmrEC8ENuLHElQ4VT6Xxc5dFiZyPwzSZzcfteU0hX1MNaoo4Ocz5OoE4CUJKUFYyQoF1XuzZyXewFXQ+LssL4XGsjPLewjaEZcsaNDrbfrhK8RH94tTsT8ZVFGJCplaMt8+8pSw9dyEKiBzIhB8m1/VC/lL4ZcIFn2vq9QZFb2Bk22MK+QraxNmNC1dFF+OsZj0F8sulN0nSiqStT0EUxUCfAVBh5OVbQVkMRVF1Vj/IEVB1fviIYewOPQoK",
    "test": "4W48iBrqCMzTJx2q1LkdBSxVCBhRBB/kIENFGkysuZxRc5RwVSj+DiN/u1DlvL1r7XXEVShcuq4sGs//x8+Xn52/V7hrW1Q6oLterM6FZIBoUgUc6OM3ez6aQxESkCLWB1rVuhRPCen7OzagRmsIyuX1pRTMQ/q5cpBC71GHiyFiYf++EscH5Kdm8pFmsSZMLQ5ZTAEmVVpcEB9RG0zrnGOfXDlTYINkPmiguOjwuGvB2dBaLHLi7KF4/FDj+NbbDTZVGDZYuArJvHb3nll6d7/OzFHBfirdPA9Ws5i4ZhRAzc48lAgFegVz0cMJ1ASws+KrTxtLY3H6TQi1ydHg3zBjhs2JlVvKkF8uTT0hJQ6rTEBBHBQUFGQ2HB52sOXFNu2MMF6sk/Jb2+C6tP0rL19gzXJr4b3quFLUHKdzzuNPOpc10ojLBxTg1rCJDWya4EOYQtnbXLEdXoan+J9x6DPU/e8QAFCd6HoblpobDLapntEKm/pVbrpCG1WP8u/nZHKzo/T4C1WNMgME+LlxSSxDHpkDQB/4IFoUR6fghtER9E9iVWiWUygkxKGpcrhsnTzZ1zgagfbtUsQ1un++tldeDkoqHYtG6P/nhI9N+4cdQg6CmLg1tTFYGcVPyCbJTZ0XdNkCGeH2OT03Q8oFbqvBuznJARXZkBdFoga8qXNeO++YEqVp7N2nmE5ocSUI09oAQRpUFBR9HRpYH0T/oT+iTDBY02ZS4yW5x0Dje7iJOZ/n0yayufoSkBnqJwvmTmtPXGd27p+EbXL57QkwaioDzELBrV7WF/l1jCOR2slQisvn/9c4dxRo4JY2Y97sr2mMRt6FUbDvBB8QoYebNB52dtsLz/uSzCOUDGfcZUAsFUkROo9ZGW/ZXlEQt3LI0PMV2VUw/R9fNrThgPqwK3h3yHV8GfT9fBGQR4tuirkC1lpSLVTDThzkLOiaTSWvD540GencU0Yk4mnUBdU7mQe29eOZGlbdn8Rw/6g9A+7ko1EIkQtI5fRNA17Td0kmZ6jMz6H4OdSZOgUM1eYxS7VBBAJFXFg1OlMRQ/ysxM6ncA2lGnzPBykhwfWXl+c/9DS12G6efvugXdMRdGeGfps9RopyXsIC74pzeZhANu15Gcp26PhUdz61FtJCpj4VF2KIrJlKWO8QKRHTTi5Obv7IzU0IRVP5f5QYlMqSvDkuNerSUwE1nZMe/RpduGBALWsNTBEZUF1qWVc1RODCnDqaDWhQSss41i8kuL0er5urPJgaADjydrAN9ELsZZ4dBjJVFC2369uHcD+8lEU8snNOp5+VbkHk16N4/5qF3hQBkZec9UcYdhJg3wcP3A+rs1aBFIdLHfCOZpDMyhedISdvugIT6kv+iSCEFGzo39ArBAMYGB9RQG9KEVo3e3HIJwBBPQk5olJmIY3Gs4H8L19gzXJr4b3quFLUHKdzzuNPOpc10ojLBxTg1rCJDWya4EOYQtnbXLEoWBqVTgpq7UjWkaD2Q6roiT9ji9IdR44c6Y/L8AYYwK/NRxD6wPpiM9PrkorLAcCY1xhDPLoyR8YMCAJFS61ZG/VUFWqJzJwncBVYGn3SETYFu3unv3N97i4BM7YdqrPkFwZ4uCr2sj51V55nVYZPou1vxMFOMPJtZJVPy0MldWpBTaJC9XfEJsvUqx9dQrfZ3ymTAH2Iv+T+mQ8GCobweQMY71GOqXNzNfnSUwEOvsknyUV3sG/LKEECC6FQVlkDEBFJENCruy4eFTl+Jst0PDqhh47ksnDONNApIC3ygbdLdoG72g4WAjRGPSs3pnGJcCPsglEpd8hI/RjEh5Tk06B0yQmFIxgAigWb6QJTdxQlM2ML45rqq1iKEvtLF4W9Ipy+yhfe3mJ/hdNO/58F9D3PETmnKEpsFUkGEVkWW8o2VFsE9b8IZexz0oxk7kddPvibbKvj+ZZojTxsJrvxxRrWUq2zlqAWHC6Z+BCLBxTg1rCJDWya4EOYQtnbXLEoWBqVTgpq7UjWkaD2Q6roiT9ji9IdR44c6Y/L8AYYwK/AQYTG5a9pPmvuyo0SVhiQ4doIM4U/CGNLRGYeERMZGkVFRkydqxFkaUFnBjCYEDhxbP8ls+Q59HmR4mA7vbH9XhsUdie3eA2eRodjEM/N70Vav1sDM0dlAMFBp0/Y/6YZUhoCpj4HQMz4uIUGRPz21XWHTnoIqKXGooLIRFrDwElQ7+eDwG/uNfrMM2c+5NknpVUWbC6ZYn1MA/JA+9leWVcSELGXoDqFTTlv0NtTN8+96uieqnCz3NUoKHKzgbc4kAbIKg3bQ8YCHS23uArJvHbEpzYxtnVOyQrOdECpPCx4jEbPCIRAzcuclBkTeYVc+ZYC2A+rdMmLBZA6F+yhTSTIz1vY2HonwwdFcVvAiXLBRXWj09psCB9VOo9ZRW/mUEEQt0vN+uZBQ//5wFZZ3KipqZWz1gAlyClzIb+7i/PZ0vtB/eh3NzUDLUXWChGzOunIABqe1UOLZ1GmU0pdVUS2EetI8Ev0kaD2Q6roiT9ji9IdR44c6Y/L8AYYwK/AQYTG5a9pPmvuyo0SVhiQ4doIM4U/CGgMQEE1FBQUZBl1GBjlg1UjslppWGiWUygkxKGcd3xKe8n34p1cv44tGw2Fxz8YdBF7UAQ6RM/ZjqwaghlvTuhlGwUK8OMFgToIPN6CcGaUFMLpkgpKQunW2XWQFzI2rKP1k5aPTBXfwAIKjtqCtXMn2q0CWxl4mx9N8QBnqioNYkoyTBFQXo9/VVdVD0yhnGanBHNaYNs41mi5aOz7nSDE125tJ/8vxvF4qkDt+MeNFzRLHnUQ8/7FcDCukpo9q8QAzUbAhpHc06BY8Di2ZdxHmgLlbzV+bYQl4ZIB16GwwNuNCMYLRvy/HRmIz1rf+Ukehco17oKApF8BRXvgZ9YfE65OQ9kLUC2XEUYQv38ASOhT2BtykRMjNruhc4rpK1RkoCd7IKatcSCVVOotpaZxHEhUN6DTXdatAKHBT7OzOUeGTcnZU0opEELYENR66Am3/LvEBjyc6Wpe5EcnSLPp/+gG5QtVhOJNBYyV9aROZzXqiFmRFtWTNZUNPKtxUStEAloSGVoVO/UeFRCgfIRbe9FmVXi0PDtgafLbsK2/oDmyKmEewOWqCw2ChjiSpQVmV/EoEMdC70loohQAZPIcCdFP7uNM/8oVFs6C9WqCQNX+h2B4TvTANGb0CycIfaDNnBXEIRWwwEkM7YLIcHMnKf+CQgwK5I9f6Atdf76ALoIIZ6EZGR/wEF6TEP4xkDrvGXsFYIdXN8+sqejbuiOBNIBVYiLvxr5RdoG7Kg4nBi6FBSwqokeRcCms8EN9bXF4yEaJb/GiPBh4d9KR+dwvzcvo/QFRfJ6L3xYXMRqfhI7U0KsHUPj9GB8Plcj50isghZJIil3viXKHBHKe1VYiEpQCV6/KGWFFRVMIovSN24lV2VUmlyVZNO8hq+fiZsonjnlrMef7gkaEOfIuiOlSZEt4N/+GXsjnZeeQU7jdN9eTZ3qaFO5dF/fZEJF66FjojqjRHEXg5zAejppoVOTp8a5I65IO5fRNCt7Fm+krZzXqiFm4UqOJII5L3aZ/RC5ETVlRW6AZ3DxeWVXsfJsubpJhVXioXiMeg3iqbbQ5pofbMnYzfqH9EwBSeW4YdEIuKFF7UdgKjaRhcxMvTuhlGwUH5OEVdHU0Uc64rnKEKNvIr0pGWPyfHy3WGmEKsuHGml0PCp7DwElBnJaNqDkdNaH0Tg2p5NlrpVUdcTYqYlFNTBEZXFQgRE5aELzlnCvfTCNaYNs41i7sabjfxGXrNJQ8YpivueckjRG7Kg3bIHwDHn9QnCG8rDvg6E97sDlPpUbFaBKsPBFZzkCRPfgAzg3d6Ao3qJRe3MJPZ5GrrKKERslL4OaCAQi2nh+p1yEzvwJ9kyCAiSeBAXOeOQVrXj2MER9ZGW/gViN1bLmIMahO49RtjotdOeb//cGqZZAliTEiNe8thBOzUaBrkqVC4pJMSBCGQtbnMfmQAGnpPQa0BMHfWLolFES1Ds6tpWvo/u7ETkTr/XVppldtYqupp1xSoF/0fO5nDsrOmedcI6jMi/fLWtKPNhAOL45kLjNBBAJFXEsXKForVlLdvYMevjtXGSWPXmEvfOijbfx5jRfU4nhmqrHwXgARcWLDcz5jA5k7AIYG/cgaeYQAZPImHNAO7vNeqDpJFt/CyDnrQJq+a2BPVOfV2XDCZTFIwqDi6Er4IRWwwEkM7YLAxH653343ZJlIoZpgpQpWlzRANlFFMzdQGUFwSREIOuyx6XurAyVVON24Ky8fg3zmnSDE+JQ+L7Kbbfk4w6GqN0jbQ8YCUWJJuArJvHbS7AABqnE+mEaMuXrdPFUWjELJCIRAocvCiEcwqNlvE2NPMU8fdOqFExEDRbmkGAX08tOo1jYiawIQkFuSzCOUDGfcZUAsFUlVHR/BFW/JGDdfc+j1OaQE05F59/du3LCGq4r71g2oo7s83vO7qlLZA+tpq0gCWE1CN6COW1n/KvTWRSziPovVFdjmGLAdDRan+NkylED17LKFHo09lC9RllccD+epjtEX5RYVbbE1G1CZne/h4GOzn6rWFKu21x5DPKwsVGN1TQV4XkBXIERIFUTouYYRr9EcVT8oXiMch4ahl3M5oDTmLSpyrvKwDZoAu7qPsj51C/s7HYtG6P/nhI9N+4cdQg6CmLg1tTFYGcVPyCbJTZ0XdNkCGeH2OT03Q8oFcajF7UrMB679vUBB6M+DbTAaOvr4FsJX82BamE5ocSUF+U6yZ69TGW9eWVcBW43qnHyjAHM3YI5PM8qxuLWnuWSB3tAbNmr/eKE19VDp+sTvBjRRWGpQ8AK8i8OxlAAzq8AAi8CNc6ae+BlWoW7RIwoQt4Co/RtWawok2Z5p1ojdstiWRwp6F+yXGReA61yf1HNdhgJZ9oqO/5jNAHKa4Ek8R9kLOmNVXDlQQkBTr+vE3qQK0/Uq85t8L4ztdaqbCtQliT/8POvbqFaJE4Z8lqBxN5JRY67PIYylOvHXRWSeNle0TcjrU4gpFF7TP2kyn54P9qjEBkPnb8QellcTH0njm2ZIpEcRkq1YDsv4iLkm2T4wolbPDcT2MIlE1uNXRmYHCp/DGQ9ZJmxRFVXkrhlebARfHCeoXiNhu1exq+V//8uVOn1Nr448DIkDfjXQq5k8V5EiRIZJo0UowqsCM0QiCd2Pl0MTdHl0X+1OkGmDFNPBkcBPFunS3Hv2BGJIs+X1kBPVCoiywEBMnh4PryZN3bP1XItS742npQBnqAIq+lsNQRpUFBR9HRpYH0T/oT+iTDBY02ZS4yW5x0Dje7iJOZ/n0yayufoSkBnqJwvmTmtPXGd27p+EbXL57QkwaioDzELMq/noMV50kUbRKIkvt2LilDs3b2Bz4wlL2BvmqtbEAdcMXO46TQHI5tC54HsgcZJP/obAzmjNCXOqYUt9QQQCRVoLVn61EUZEbLnNN0wLNHcKlkVmHrLbq+7v0ZRhiTpvJuOrxQrRVKJgiqpA3UoRNVyCXdHlNufEQnrdI54RCwPjF0ogBEOZDwFjnlDP9u8QAkan/RhellczA0f9pJcGnEUVgqAFC2qLj0sq2zSv99bXHcKY1x5WPLZyBTEIDpg3Vo/OIFRFXRDfwhZxe6NdHCfPUXNnwI+Xdb95xyqG4mAewaLsFwwYcyK0q6ZbRkEsR2J0iKBautoBKuplAwUG9uMDbWlAXhxHkSLQDgrYrNAOWLnaViv3AmEKue0OpRSPIRWwwCQY7YL2cGgz3PTXXcdNnY9f7AtduGBAYmx3GFBNXGRwQ/RWXbrto8rpSB2aNIIPNy8bbPnqw7DZHwRaOF8vxvF4lRr7XcaeQywLHn1QlULNxD486AwsjHFO/UbWb6Xx2EdW9QmFO+gAzcucjEUWnJ6oOgA+YovaqsnEB1gHQOTvQlnDpvTlPTIifd2Py68MzHKCCyCsZUsgQQQCRQImGW9QERl+rZnA4uxO+AEp85smOq8vbefoLtQbyVV81rv7eAvNUOByluhNYkYBNlS1Cbr6O+qBUzvz+zSVTgnZ3eQjVRqVTgpq7UjWkaD2Q6roiT9ji9IdR44c6Y/L8AYYwK/AQYTG5a9pPmvuyo0SVhiQ4doIM4U/CGgMQEE1FBQUZBl1GBjlg1UjslppVWuS2V/pwfm0sLE5/iiZLndev3qkBsURczPSq6BmTBUyQtcFmqQfxdNJKu2oBdZPnal3fDZVXgZCoWPNDJ+IrJM+RObZYyeTHGURsuWG6EnIITa/hR/MjheNcGk51qLGQsdJkJpz6EUltWZBJ5dZTAtZUF1cGRE2VqWwyGaaDmkPYJ9QPDS9uPzlxCDZHwRaL8Obh3/4yVe6KdDiFyhx3jIQj5qtrSbgiQBweFsO/UaBtkGlNXddjELNIrIBkZz9xosEcZgmOct1PU7kssrIRtkOWfW9DBmZ7sno1jZIfs2VzAeIkHLMWo0hKAV8QUlrRFc4XDt3UFFUour2339V0opryFd5LOmhbPWt2ZB9pSs8I3usgpmZX32/8JRCN5JRY6DVXd75OrPHTn7yPACVUdnmAr6cAVPWA2grlQiVjq0QD90t9WZbyRsOBLbbmcAOvnEVv46NLtWKpLdc4D3u8DH4WxD21tEH1L/zT8BBH66QTVpXJ9VFRUXsfIY59EEcVWD0XnAteP8hc+Bq7GHZMWNrgfLnCg6FgnXUdQg8Toc7GhZFxcgae25ADLM8Cq9G8aZRtSJaFs6C9SKEA17JrII0FuS33jaTCXlJuvTNn9b+IRWwwEkM7+y0tysiZ+8TXgt/pgUm9lVquG/RJ9dCGUVJTEkwFjk0FfLCnDrfQTkVIw13PTPbuOfqxySBOstvNnKacvEW/kXyZ1O/+DYCUWIQ6/82sSrx79Muq7QDjla2q/Hk16FT/6+eCIRAocvU/7/+aYQlMg1A1/yjdMmLBZMCF+SfZlnJnhelPWJ/hdZP6/uT7TOVADnoZ9EzDo/MVkVYTTkVXoUYdKeI44YA+QE//VdyMO87q0btYcUllTMpNbuze6mLGI5B/eh3NzEQN6CO2IXlOfLHEW8nNQHWX17mXKIWVR0YQwE7kBL38vzJTlXx9WBblpZaDLbbiIQAmUwBa3EDTMjEm3UzGD3z96q4WsCPNgURZ46eUSIVCEoYVkk1JlQRUkmhqJobcEFgG7PJ2V/hu4Cc/+Zm9DS1AGcnxKf6GgZSvnr+xG5jA/F7EIZ0jeEur2lANfYpGsBPn4x4bH90Qs6J9W7NQNjWqIQ0UaLQ1HSQZRsIbvnIhoTOX9WwuBdJjM3OtHJoPv+4B4V+5NknpUVpqXpFJQlMGEV1Vo/lEF2ZU3jd8XWfHWFVMhd3Jmj8eaKiszjKNJclYnCqdfFDoAn73MPaFyMMB7sUl9OJqTHH6AB9dyFOoRjEgpX/PAZCzR0UItlOigbm6EcQdJF50gYBMQnktfKrTxtLGKSwQEGEoxPgMDdfvgdWl/3NlHaMSDHkJQ6rTEBBHBQUFGQ2HB52sOXFNu2MMF6sk/Jb2+C6tP0rL19gzXJr4b3quFLUHKdzzuNCPAseSB7MCajdOriBT7OePprSHMHjHb6rDB+ID26tlEf0lPTfZVug6DRu5Qw/HKPpidlCkUMVe3tOTJT68qRo2jOziUfLCsWJ1soFXvkrQnYTQpcDXF6NLBAEBAKgxYYRr9FoEDT0DC1gb3zcgrNeoGP2Om1fd+L7EJVEejWXxlIzGVEsR2J0iKBatIRJKs6oTtU26O1FgTpGQw9WkCKUQNj0tYMKFq742nDgTmEvue0OpRSPSFuydA5CiZ7Orj6zZaPGM4VS7skamE5ocSUI09oAQRpUFBR9HRpYH0T/oT+iTDBY02ZS4yW5x0Dje7iJOZ/n0yayufoSkBnqJwvmTmtPXGd27p+EbXL57QkwaioDzEaLryrWNFdWrQ0V+cAJkJSrlBsZqKBE+ZxBZSWmqtGKRxtCPhPxCB7JzMr94GBjds10kpyF8XL0RTrgIQVuGRgMCo93WG/1WEZEtO8SOelAPR9w7AsmZY3tq0+72I2d/C1p1uiucR4mE+Ji/dUaN5cPSBCGChyl4g0gKzTnLUeNTcrwU3RqVRqG+JE76EC0jvXQVQndqHkx6lFiBLr9iMEI5QNghP1ZQtSKiqQk2GLx99P4Vge2CZIA0OMxXRgITRRCEDMmJVVFFVPjwxsfe9EkESbYDHN7u38nrLZs5XuA4nder4+xXdMRgzTUfpcmTAV7D+pL7Z5jqsAOIulcCrx27PQZfDo2+KZL9W0LAd8+rJl4QrXfHy3WGmELs0iFoU+1IRWwdR9K9Z8+wyRd1K+QFck+avNn5o2grWMF1zsyAFRNGVxzXVoUQezt6i8wQSBaYNt1PD0re3yefiOBZNUsI7+qxrIQ/Fm8KcPoAWUL3l61pkbJwmv5mQBgjHFOpBrHvpLx06oYylKTOYZAg+Tc96kTaZtlKq//4QjrdNqBCd6YF3iuD6bJkvTlPXFhfNF+7kvI883RBGfg4EB8E55BWB/2V7wDGDdfc+j1OaMP+VUwjlJZ3Kigf0ieZxszjThi1r7ygViZWI5BjatWN9A2LVPNCdjePOjZKzTnPpqGGdG6U0RbBkOZCZEn6De/juz4DBbdu9xe9RklC0HpzKgtmUgBv4QMHtnFi4Rg4XSz8mH4WsWJNN9W+Kw6SnRBTlQTGW2y+VJ2W/PnfIolbUFDKjCOCmV5aq8qtvkyoD+24U/Ywr4kXgsDhj81boZ/A6UsUhYWxaRarNBG4KE/HNpB6uNTomgV+KZCljeLAcD+rZdMFtKrNGfHCS90uvLBn5GBCW7u8z1AmJbOrigm3rusWxlIpYQN5o2crjNANoJNCFg+GQRDEBFARPapzjaxCHMSYN99Li7quMOFhjKI3c1lYm+/h+E6woHi4cGzEWJQGCoX65yV7XiHu9p6wyE+pBbNc/Hh1oZFjFbeIxQHnZWx5Ed3eJFz4wl1MUCgqdXJBcILU30yH9WAh+Sh3GYifssI7kuE98GSRSHSKAU9EpIZQR9RWmsRU/gVe0qIMb9E1BpmjotdOaf/sNHJ0IF5/DptPLyjdpv+R+JykqpH35IVLVPVCgT34biJQTCoOUeRAIL5U3skAVenQwFb6DqzjqDOZR+dlDQelow/DrK8iNYPmlpVg3UPC1X68qR6M97zypXkWxD21tFF++orHTAVHpV4X6/VKFJUWRDH/t6xf5BbEGC/IXMtbPmoqrN97i4HVU9bua+6GZV3cSqTdQF/A9oIEIZGnKAdwYREKeE7TtIG/4seqDpJFvMa9Sb++wq+a2BPFt3sH8qTEmEMs0OIy/nBTkuvclkB/bGOcDlnNf0WVJo+zt2n8ARtbCBDN5cNCFg+GRRiEFZHXbnhnDPhEi5UKcsO3y8TlujauGPNNNApICHA7Ol+8RHp+tDBAjZSHTtQp9TKwiapu5B9sSMBpBaBroLm16ZX8EKZZM5PmNvgypoFs293EZdKZU7exN8IHhFNF3iuD6bJkvTlPWBjd3k+8puM6HLJEG7bMFYiEpQCV6/4GXMKEVF4buqBEZAN3AF57oh6P3Papuvm1I6s/D/8NvX6d/aEOfIuoadQ1lpCY68HWczhJriCACCcM6j1Z3qaFO5dBVbIBcV2oRDL/vTQCR0hyi2xlkI0SPuh5xQql9RZfPAITNjDnaRo1jTn9/vNH2WQNhdRMq57DE/BTQkCS/oLPRAZ3VyvqMZiapcfAS80Gmpeavn8baMwiofU4ndiqvL/EJwCx8+Xl5s/V/dpV2ALm0tdqxRJKs6oTs9K/0MVdicZFwpNlyGEXZrjsIM0GPSUNHb1DGJEbwmBkoKPWVDawEU5pJ8+bz/bNbL2WIoT5JQdflUddCIFEoMEA9UXGRN5O6EVVbryyWrfSX9+Ict6DX8qaq7fvCDVNOxBYn3bgL9M8UPuZ2CbQGx1UjJrbAq+wDfrpQA+8HEPoRbNf/HfPBFZzoGYCKhMixec6okXeNAd+hEG4omffx7DBhEGCfy5A5a16trf+TtiqJI1y/vNpiKSEWfoZ9J8XG2MEVcMVj/IER5Or07+4rhVZFVinkcePaa8fKq8KJRziTEi1uKuvHXmX32a/blWZEt4JWaJT4+hNueQAC361VOVRdrmHakkAkPYSJ5I6EDi9ffEQVDmyHBE5QZjAKep5MITmpsWv42NQZ4La+Bq3iy6yF+3E1X2YdEGPIYxVzwBD6dRGotmQo50FRjlg1UjslppWGiWUygkxKGpcrhsnTzZ1zgagfbtUsQ1un++tldeDkoqHYtG6P/nhI9N+4cdQg6CmLg1tTFYGcVPyCbJTZ0XdNkCFu0ZH6H0RTEwsPDBnR0NT/8tf69NiYLBr8kc1+0BQwIYmgEe59VqqX/QJ5dOCUIXGRN5O8sYXajc6HffMzQYEghO1jWsabzwszOQHugaYn+mdrR4w6Ho0t+bXopCUThQhl0ZxC0s6AB9fHFJkEbSc5CWPFVKjDHY0MMMixfny/UWrgElNtkPN5yfxdiV0IELS+yXGAGJnhelPTIswssV7kvKiXWARWbc3QVwQUxNEUw1SG92DoUXbO704rsuPVUdjnd6Nbygava8INhliTEi1rC7w6eZQr2f/eRCMUBRMVXXChTv4bWDQWTh1UyXRtH5FOlWVR+EQqo8kEC0jqiQTpndzXwqllUoQPjo7I/Y5QoXxKRHTIfK8v2hYm3u8BqYGICONgBqFq5xQDtCCBoFUFZX+XcEQXaa7x2rcAVr4lu0Xmdcb+moqvky9HnU2m1urr36HsARvy7XwEJiA5IyQYdL9aQjxcAA326oTwVP8PIFaiRVR25VjH0M+wq+a2ATFsz2ZGbKTmoWlPCI6E+BCoWwsG2M71rOvDkB4r8VVgxOmgNnq9Uog5IFYlFNTBEZGQ6DEBEVEOXxrjeiQTUZJZUYJmC6uMLihkaNNJ/6SXLvxvF4jRG7ZcLpBWJK3jIQ65qVcAbanlQotSVOyQOEaR0x2F9WwlfRXYkA/tTXlEdWqNAlOcMD2A+cwMCrRxELF4W9IAiZnh+h3HopdsxXinWMiQiIRTHzA5V8QUkMER9ZVSo3V9FY9dLIOaYE+VUw7CAjN4ihgPrpIN93/Hc81v0yeo7NW+Jh/fNCJ76eY6DKTsilOvDUVDin0GSVTdGmNPFtAUan+JE7nAXPjvfZAVHp/WBlyUcwSO4+7IRG5X61gbMBC2jEpPR/GBjz9/3+DxCOJhoF0b9xVyFBUGYRGR9ZIFYRXEPGuYVue65cByH0Cmtchfmrf195oDSUO7d6ufLxG2/YdVTSdoJ7WkEoAxZ4p0Eoe21RTqJoTwUK83AUqEdAWc6KiW4KBdbSaYN3Fu4Q3Hf2CGUAbvO+7E0SG6zwckcFxbGOcHFiYf0QUw5JkZBn96YdgQIFYlFNIF6KTR1qXkkR0aWs8zbfEz5YYJhSInmluOfxnQuENN5fNiKfdOh08FLjKdSqQzUQUXdf65rJcD+u6E9i8TQDoRrYtpKsPA/KjAqCX1ENnhf9lBpEqIRd4wk/MU8fdI7EAdo0Q4COTUnJndrh0y12wwI0ikvAuSCOAWze4AVuDQ5CV9kRGTxBERdQc+jG4OhJPQZnkkd5++GteryvCrhl/DMzJruqhAaZQ3w7/bkCKn6RY6CGQtalNueeRSz7JR3VHMHyG4/n4o0YQwE76AXW7vzJZR+dlDRbyoolYqup7IRG5WZUb+RFAMnFn+BkMzSv99rXEhm2I16qFq5xSSYVTRgUW6/3LEQRDoDstZ6br5AcWjC+XnAcaKnpg3Nw7zCU1yknvfKd229Rx7qRfppjUVEuEItVxaRaeYQAZLdpGsYHp3BRfiUBXqJC9SKEQJrGa0UCRr7JND0NZTFIbqCI6E+BCoXegQQ4mMq6xW/211T2TwE3la2npUUdbC6ZYmIEA/ZVXElzX6FNELTjh8rfQTkVYNs41i89fujnhmiEJJQuKm39xq/4yFio0w4tAicRFGJalkazt6j7lUh5xVsO/UaBtkH5PCZD/UKZXY6AnMqolBpEs2AgJ4/PMU8fdI7ERxELW3mpTQKYngPl1X2gh1ZTipzRiTrP0mmhKAV8QUkMER/QXj/ZEQ9QcayI0aIE1kUyy5smKentcNH8IMQl/Hc81rv7gBOKVKJtlrwCZRBR+/zGBxzf0rSrAGTn1UfVEdHDAaNhAFWMQw/27EDInaHQHASklD9/bUdoSPup7IRG5QsZePBNHYXLiPQ5MyfzyRrTHdf+Jx/F0bx9BSwBAANVGVV1Jk2FXRDvbt6ncGtcVWD0XiNhu+ncqKZloG3F4mJbfrX9Cc/CtCqF/EIjA/F7ENxLgLUqeYoa+PI6BsoDp3BYqDFLPN6C9SKEQJq+a2A4XqXQPHnWGmE0buzBuznBCkytdEl3mI7OtyJ51r4RUccA5I9u9QAdrS5LYpBNHkRIGRRiEB/UELTjnGelCG/1YNZB1ni8g3yea5uENJRaJS39xqJ496GqN0jbQ8YCUWJ2okaKqHbb6F1sw8/9/UaBtkGdYFVm/RLF3hRN64DclEdWqNAlOcNPOUHQdI7ERxELS+yXBALO6dr51ypiawIWpXCAiXLBRTmhKAV8C9lUOo9ZGW9QEU9QnujFOeIbMVUmn/NmKeb/q40cCtQl/Hc81rv7xVb4XqBrkqlKN/FAY/r2IYyl4bjEAGTn1UeTAJPjEPclVUXKQsxI6EC0jqiQEo0M5ysa65o/SPKP6IQV9A1VbuZETITVwPQcM83z96q4WxC0PZMA40s5BTBQTURXTF1ZMQERGAfTfM5er9EcVWD0XiNhfbPqqvJ88DTH0WNfuP4qXhEDx7+J/EIjA/F7EIYL74RaeYQALaJgFxRDp3sDsRZVFs6C9SKEQJq+a2BGPLmQNDqTTmFIbqCBu9+BCoWwwBFMgIu3cDVNOf0CUgZW5IgepU57l75FYlFNTBEZGR9qXlNQU4v5nG7fSXtALstH1iWmuP0efiCM4ZQy+yqA7KF4/VTjKcLnBisHHmZD65P+cGXs5lF9xTQ4yEa0tk0cPB/47o+RPfgAzcucyAwCqI6yOdgPYpjddPPgRt6FPfz9TUmP6Nno4HFawtE0komV9iKZRTHzKFlpQV2REUEZAiMQEEkDtPP7OewBPT9w7AscKr8fq4ve1bh3/Hcu3OuHbQrLUOFa/acC39tCN6DJTYzkKbiJTm3z1TXBBgPjAqRmGVK/QsRrpQi3/KzDTkDryi9e6p2lSKzkj2EDml6Qv2d3MY4L6PlXGD3zi/fLWsO1PgEJ346dTTEEH5R3VVlZYUMRDoCbv16xaoAlVXu0WDJhh3XrubMce8SU4jMeuKLsGw2WczOXeUIvHkEjWNROjuppx1AAMLxlALcPp0NRqDo2HN5uknLQCNe+uwU3Qaz32ieTBzJIv08Hk6KBT/qzdQxE61qFtX67NbyUGghWmNle/RYdqWRAL5QDGEIXGRN5O6EVELyxnHejBHAQLxdM1nrHuLiehjWIZcFVYiLvxvF4lRr7RMPjBjRVGDFV75qCtTvc6EF9xDAAlQCMap7d4okZ7p44Is1Bkxvo/UEWss93OcNPMU8fqMiQRs/YF0S9HpyPnaWJPXsg8JI0ikvAiTSOFmnoKB68UElYX6/NUTsVQ/k4c+mI4aVuPVV5jkcm3Ki5bKa8+1Qw/Al7PKeseFGQXaYuyaIH3EUFK6DVAxzcM13EAGTn1UfVThijB0o9VQqYB2Rj6BO09ajZATndlDQelldoSKK87Jg05VMVtegNT2GYwPQcM83z9/bQFMXGWMFFPP5xBWIZHzYeXF22QmwFTEDdfMcfr6JhBGDG2XNhvrjc7LwssiHF1TAirh7LVcMRun++tldeDkoqHYtG6P/nhI9N+4cdQg6CmLg1tTFYGcVPyCbJTZ0XdNkCGeH2OT03Q8oFcajF7UrMB679vUBB6M+DbTAaOvr4FsJ+7sRYflljbE9FJQ5VCVUZSVY5X9UVUa+/7yLlAG9+MsV43XGH6qGbsnCC41oa3XKbbaE+jVC7+Z3pQ8hKEGI2zAqLaXa5z5BttiFD7lbDr/7dMUtWlAORLgwAj2PcmWUWqJZ622MJ2l8ievKERxELW3mpTR8I71KoPSdimsNI/peC9XnCFizg4EB8UFcUEVBXMj9QERV1aLmI+4dCPRN5lp2mYvissPqgIIYl7VV81rv7xVbNQatB/egCN5JRY6DrSsvdKfaID7KePpvVGhDoH49dDTmYQwE76EDM9fzYTi8m6EscyBwaDPuc/vgG5QtVv+RNTMWOjqR9M7vzkFi4HICF1x5LFq5xBWNBTUpR1V6KIURTWRehuIpee5BaGSX0BiM6sx+cbbM5oDSU4mwYfvK6XgB47CrXq9JpKHtrV2IL74QdrNZSP4IiTtkPzLNMqHwVHxBO9XrN+s34v2A+WPbFZzzKTi2Idv7E6BbICp7wh9lU7ZK9iyFiYf0UUx2I5M2n/RotqS6EYpNNDoEXGRF6UREYDuzvnD+9QXg1YNZB1iDtuLD/hjLEOYwaIHq8xvoBjRy8Kgv5QyQCXHpQoQKJfVXs6EYoqHEIllaMuXrdPFUW/A4FItIGzgmcmUcDdwN6+YEWMUCdsx7MB2RZRaC9ClWAnd3fFmIiwwJY758S6HLJAiW5KEM/SG2zGRMZFGQ2HB52sOXFNu2MMF6sk/Jb2+C6tP0rL19gzXJr4b3quFLUHKdzzuNPOpc10ojLBxTg1rCJDWya4EOYQtnbXLEoWBqVTgpq7Uj0lPTfZRfjlF/nyQZXD0r96xRM7CEagOtJG1WO8wJh1jOz8orMDsKIMZVqFq5xDW/BL5NDXB/+J/kTXFehqI2wfUdcXjyo2XNhb4XsqrMy6TTRMTYafubLXc9RxzLZf9IeHFF/UYZhlL9MvNUONe15ZLcPp4dUfDpQWh5WnCK3QJn0aZUBQaHQKRHTTmFIqKXG6DySCo7i89kM71rOcEgu3sXXSsE4mYlzzGdWbC6JJ6VNF/RLV6/lO6EVELzs6WqrGB2aYNtTN7nsf4Oru7DM0M2a3XLshfEt5FmR0t+pEXNTWGIK65mIcDv8lUk9eksO/UaBcQTnPAYWkVneIxRAzcuczQ9WecAwOdNPZQCaqx81FYFOW4u6TTaQ6qjo0DonfdJP6yCviXKNAG8hY/ApFUkESR9DGWgRGBUKr3bJOadP+B65oyVm3Kjts4H8ZYw6jXcuA0Pql6vIHaF7j49O1kY3LBD3Axyb2t3EAGTnNoq0TgKmXKIWVR0YQwE7mQ+074iNTp+d6HobyUcCE03Dm2VIl9J0er5IGM+F8vpc2iqkkortAdjrNgBL30VhUTwuZlpRVVoN+UBQTBCouYZrclEyVW3+XmYjbOGlba95piWUO7lywfKd229Rx7qRfppjUVFqDvpL74RaeYRJIqI7Tx6Pl0MFcH90Fvt0iFHBEZW4tIA0TenV3G7WTiQGuejI8BWMG6nD89kMoYe+cGgy3v++XwEPm1onjlUerS6ALRQARRERXF1dXQMVCuyq7TqaDj5Y+2sF1iatuP7ksziEK0gaYiLvgPQRjUK7JxzUQ8YCUWIQcVLE6mvd7/MoqiFGlAGUa9Cd0kpWlA442d/SzhylbzUWqJoo0cNHMUPodIGEWftLF+z9H6yEh+TlPXgndwJJz6zAx73RRXXhY5Vb+lkMER/QXj/ZEQ9Nr+LI0aIE1ic5jkcm3Ki/q3HgILs6oHcuObvwxUeQE35B/egCN912MVWtChyl4bjE3oyYWlfVAhTyU3orG/KNA1U78AXV8eDBTpndkiUe/5F9B4Pp5MEIkEYHv0gNSdqLnewx4mfz7BqXX1H23MFC4qExQClUAEpMMo9Z+RBXQFfgrd5jwGtcVWD0XiMLcOHOquIr6yiTLDYafvvLXc9Rx7rXq9J+SpIjHtsKj4RivcFOZKF5Tw6RfeNRqDoVFs6C9SLIB1a+utJPCenDND0THCBItef76E+BCoWwwEkM708XrUgiZv8CSZA3kZhzpUkgsykI19E3XR5ZEVpyRVpHEOufpRGfQTkVYNs41iGswMKrtnDUNM2jSXLvxvF4jR7IAZ3bDyNWUWxQ8AGJaXapu5B9dyE3opCFg6LxFydWjAeU2xQCjw+dy5oTbKc9+ZpLZArrdIDBCNRGBKzbTUqIndrf+Hdbwww39QaNmiL0RTrfKEAsFABFEQMZEWgRERdQqvuBOadP+B65oyVm3KjtbffsIJ1lzWFJ1rv7xVaZWOQuoLhP3UZR1BC0CgylKfXBT9en1UfVTdGmU4BgAR+LQxp7klCUjraQB/7WlDQelldoSPvDl19koFx0b4YCCNnIjqQk2iymipu4CYy23xQL+0UfBTBIZlpRGR9Z+VV2R/WTfM5er9EcVWCXG72havn5beA5nmSG4nxdpKK6Xc9Rx7rXmRse1RQmHsV3oNgaeYQAZPJoTwVPn1AIdUdQRcYSpjiAF27Oa25KWOz2JTrAR8FAqee2nVSBAl+7sURF5OGOcDlnNf+SGcc+7Khu8DZgvSZVMQhJGVJNGREtX9RYA0y5zmCuSDRV+JhRJ8WauOenf5urNJQmJ70vvvFVkBr7Iw38+DYCUWJSol4Ir8nxpHdlxDhKpAnVzXrdPB/T8EL1YcRA9hvkzUdMqN2kOcgRMUbhbY7MAdc3WKzbTUqIndrf+Hdbwx50jB7AzDnUCDm/A5V8QUlKRF1ZSz92DmdQr38IOexnZB5Ty5gcN3mdq+ru+1QdlTEjPbuovHXmE+I8y0h63UpHJkePTt3iOriCVSvoJQ4+AZKcU0Yk4mmYQskylED29eOZGkOdjGoxlkUoTeqpoMlVkQIVtfRKDYzOpKFpM7vM96q4WrnUIZVL3u29QRpNCAwFGRESY69RTkXuwd5mk56rAWfWH7NhgayrubNh/mjbVWNnwr4kXgs3eW3XwEJlTRhrEMNFiL/adKhAZPJoBMA1/0MXaXAGUc6Jz7LOF17OaYQ2QayfH8qTAiQ1bumBkoKBAkD/hQBM9drJsTki34P4EscA5NxmpQ/kvipFJ5dYAREEMo/wEBFZV3ix7iTlE8k2ON24Knr9uKDernD3LwQyMHK8eIs4jRG702ezQ8gEBCpQn9L+xHa5z7w9dyFO/UbLg5LxPCgujEz+IsQBpsukyQgGqJNe2YBPOQjjs1WETItLW3DiGUWAhYelPTIb8L50io0F7XKPCyKcZVUiGDIAWEwNGWFVXVB2r4LIPPsB3Btk//ZmYvjuaPrq+Z25/DxsJf37qHXZE+IujatWN9E3LEOGAcHh4eXXCWTq1R+VV2rmC3ddHF8nQwE76Ai+7qjTAF8qlDobypwdSPDf7M5Pl/dVeO5IAYD6wPQcO8jzclOLCMG3JtEEPLR6V82BA5xRWElZJFcCQRDCqIBwaoJkG7n4IyMch3ypqvkl/mT0OWMivbHwXhwYbGf0/EIjA/F7Vt/Z70EwvNZZZKEhFNBP/ONRfHNV0Yta9SuNDs7WvJQKUuX1NHjBAHoIuu8N6APPX/8tc5pYpITAcEZiSv7SE2Zpvskn8QBxbHsEL6EBCRFNUUttQk/+XPixzmrnBDkPYNp31mi8b4DnhmuEMcVaLmrgcvFCdoG7Kg4SCjVWXnR1oka2tTHs8Cw9dyFO/Ubsb5LxM66X7EKZZNEOzgPciVEdqNAlOcNPMU7Jv1XiAcAFRr8wHQDMncvd0i29eskXzkvIzHKITB0hKAV8QUkFERFzTD9QARVDtMLIOewBNHcKy6EiUx4hgKrzIMNk/DxsJf37qHXZE+Vv/c5H2kZ4JkeTRvP32b3EDWya4EOYQtnbXLEoWBqVTgpq7UjWkaD2Q6roiT9ji9IdR44c6Y/L8AYYwK/AQYTG5a9pPmvuyo0SVhiQ4doIM4U/CGgMQEE1FBQZYo9ePo7mfKcbcARqHCP0CmYub3XmqONk9HiYN81euaGqXcMY7AG4sEJBS6QtENFO70IbwM5MZKYgCgUKz4AUeG51WZZClzPWEsK4usAOFqCV2Wz2QyhLreiE6BTEWkuedENM5dK9iy6v2OPCTgYVmslU5AopbG2DYoMIHFgLTTNDGBtV+bvs7jamDyNVNJILPmjsaq7uuHKQSZQfLTGze4I+76HjYcKbEHNSH8BE6yD0tSb7k/QZd7YHpQ3IaVHcPAZTzo0Y01wvzcuc/QFCcYRh4w2PS6nmwMTBOhlLR4quCRyK5tCmPXMifsNJzBaSiSCEFXOv4As8SlRzOkV1TW/DVFZEdK3GObhI+R9/jpljKOLbf4qgIJZooDAoJrva7kaZ+sA/gPtBY9t3LBCO1PqfCf81VGSzOBuZCunaU3ggBVzKFw64uzvTlPj9BkaqlHNbyQw8A0ypmsEIp/c1grwNGM7Anf1c1jSzlkX4GcK+JhpA1vpxUStETR6UQUlZJ/YRQV8dfIVbfRJdE7X0CmtgbY+cbbNi8X8Y4nEifr0xDI/2hiLSb9pjYkEqV2VYnLMfe1kTZLNoAsp1/0M3b8p1WJQLij3EFNOTtg11GLm+PRHgAiQ1bu0JmQvBAlHtaB/M9dqdbyRd3ba1XsdWnYhznEU6l75FLpQZTEN1SVYeRBEIEMK+o/0aEzhUJgg43nmxcOyihkLKUsUjLn3hgf57jV8tAZ3bEH2LA71Q8ziIqTPsk9UlqSM+yGXurkrdSBk47lLY1YQBzhzs/Qo4aZpl3JI12E7srMiWAhF4X3n9AAy+zMbm3DJbcZJ+ipyJ9mWNAG7iZ5UqCBhYEVwWVmkRWFsZcfa7OewB4FUm96ElNO7tevbo+YwmzydXOvb7d5rLWOot/alD3AITJoDARNrgPuyQRSDnJBi1AY+mELotBkbWFs17p5aJ/enEQR+jjRhRypw/SLnop15gkUgNa+QLAcrGmfAcLojz9zrNEdfJNMdO0f6fTClVClpZXloX+UMRGAfgux/nc9FGJjfqG7ttu4aAdrNz7j0ZP82YpKvuXfJBdGTDbpF7A614EMN2nL5vuNBFNaIKCJkGqLcRfiQ1VZBCkGqQCNfIaYIKQrzC3z8TAXh+seHEnBbBS/qswBl3oxa0si66Nb3hGcc+lw57862xcC6KMUE4DV6KXEww+i2UW4WVnHulBTlFMwQ0J8qxaejfhiKBZNtsNimvnbc4yF8jYcLtQyVDA7116/aBtXbapVAuxCV9/UaBb5Kd06BC8RD4ZdBOzcDlbzU3ssB242MO4l7qqti1FtRIQ3m5TQyR7Mr9+XshfJJS8FuSyDrSAH8lKEpsQRhYRFk1VmlQU/wUaO7H+0xI1kUy7RhiM3Puq07tZIEhqyc81uevgFb1S3FrobxL3UoRKlOGTdCyLfHFWSGj1QaGTgHnAb5dG/DYAgF9oQyX8fbVTlTg5Hsw6lEoQJOlm1UKmVIZv3M4D1jCpLMXM83zlVS0HhCOOxhQ1LpxSnYXCBhRSk6QO/URVFfguZBhaoFwHCbVXywhoP7ctuA55HHWP81mvOe9XhgZgia4boAjTRdyENVDovEmv+hAZPI7BsxYp49Eej6VQwAH9WmFD2e+twZPQqSVNHfLDHQYuuyHn9vBRE3wgUlKiI4CcHcm2OiGSZhZo1ZnvEVatG2KMARNGF/1Mo/wEFkUROjsz83fDyNVNJM+1mutaaSxhiSM21BaL8jhgfEW/k4s32uaFycNHjJZkQqIrC7tiVN9x7MLlpvTd6Pp3VtWl9reCM5Fmcvs55BCbZN5OgVPLGLfdNmWHftLF+z9OUL0ytCL+XsfhckO7kuGciLBEyWtYCc8QRFM2k6QVW/CVEV4femINvRuPVV5jkcmKr8ddvziCtQlnHdXHYeNxVLHOfIu/egCN9hUN6DSTsG54aCE3len1UfVTdGmU1hnIVOAFwE5f5aPjvSVGo0kyWRi/5JlBvfkmIwEvptVv+RNTPTLoexXM83z96q4FtWJ1wMA0L2fUWN1TT28FiR1O9NQU/WghJobh6UoVRLVOTIoh4yqqrw2oHi+VWNnfvK6XhsUdzTFfz5jA5k7GMML9aQfs1xJZPcqZJVPp0NRqHAQQs5WkHuQQI0+6qwPFumQNDqTTlNG8uXQlE+D4kitwAtDoY4BxiRd1K0XQgp4lI9e85tdtXtFMQAEHkR2GV5yVBF0V3bsz8qgAG5SKIcF1WOHuLiehnDENJQN0RChgbAUp8r7Kg3bQ8YCURA3fVe2wCvg6A5UxD5ApQvZdFax1nwF8BDY0MNAisPzb9dWqNAlOcNPQl+Vw2mUEcULH2yjBAL28s+iMiVndrkZy6yL7SCAByypIQoh+lkMER9ZGRQQWFtfr38IOewB1RAljpljKOLbf4qbILcGz6IzI0y8g6uZG4ZrmbwONyB4BFHPRcnzOrTgACjdWlfVTdGmU3ggBVzKFutI8Ev0x+fFDFXg5j2c65NMSKfkjcAV5Vo2ePAFC2qLmaRq2j4wpEa4EcP2IZQG4ekeV7UUAUIREoAmQkoUQRDvqYshaoJrEmWXICAteP8xvOMcoHLBMSAzxbiq229Ra7q/tDF8QRIyQcULcsgae25AFqpGDd1B7PlW/8oVSs5pylqKBsSItJE0XbvVH8qTEmEfcJyFkAyTXkTydEkB/bGOcDlnNaLATwwp5NlrpT1nyz/MLoQ4CREUBmNwEBEVEPbw6G8a+o1ZJYc4ITiruOfrxGOBZd1gN8fVfaU+/BGaKcHuDHVWGCk3uArJvHb47yM6tSUHj5HBrnfpPA14jEbPCIRAzcuclBoDagNo+IAJZATfxvKERslLZf4JCBa+7tzoPTwIvwJI7oqU7CHIRTHzA5V8QUkMEUwMW7wVQ9ZWeKSi+OhA+QAmjppyO4ygesHJYYwp/CpjM+yyd5n4ROhuyboCLAIDJlDJW2ic4aCrAGS3OBiBQY4dAdNcGVuYE1R6opXI70rFAjyk6HFjlol0Yu+kiIRO8GtLxKRFHxyR8vZhYy8lo6L4Ut02+MEQ1uFdBWg4TRgUSVZLPR9RDoDuuZ6lfBUcSEu0Xmxbu4axrKB//j4SK7cnrKLkFgo47CrXq9J9A8F7VxhCxaRavM6TI26oTwVP9g/esDZVGcVPyCbJTZ0XdNkCGeH2OT03Q8oFcajF7UrMB679vUBB6M+DbTAaOvr4FsJX82BamE5ocSUI09oAQRpUFBR9HRpYH0T/oT+iTDBV+sJkWXCyuNvbuWWW422aNm3gcvEZ8Fa64ceoDGUMUW5ZuCHFtSqspkI/tHE+mEbPd6mgPBhWoW7RIqBOmgbr6DBAaZo64sNHRU+jqd4PEcFlRqioCQyHyhf5ZDJggcc3k/uLck7NAG8h4EApFTI+UFVMXBYAEVsRcKiI0bNB0oAzy5ljNrewq0fnIN93/Hd9IKq5xQrAE3ovjqsCP9QELBDFSt3pNvyFVCHn4FCaTdGmU3orG9K2A1U78A0O/PiYR6+om6helldoSPvgmxQIm/dVx3E1TMvKpLBl2y0nkorNHd+YIIQL4el6BT1JCAIeGR9Z+RARFRDavYFir8xXVWD0XiNhu+ncbgErwiqQOzMdvba9RN/8uFaSg6YjAB5oEMcFnutsqdFDMPomV0cPp0NRqDoVFvVZrnKEQJq+aZpKQun21W7ADyYNbrjIal0mBX0zhA6MohuDtSYnR+8zXx1O5Nde99VasiwXJ5IZQ6MCGWRwWVdaELyxnDrfO8ly0uY+ICqtfa8efjjBZd1bJD4zxsNRv9T6+NLsETYTWGJsuArJcHa9u5B9bks9jQvVtoLm052Tzo+R0MUNisu5b9dWdJV5OghKY6resdjEWhFpF2rvL5PN8xff4HcnqZJwlSeF6S0BRjbc0U5pQQhDQls1W8l3EphQoO7B2ZBBPSg5vVE3P4eaaLnzIMoglSppMfiyuVbuHcFbkPlHZVFR1ozG2vP32b3E2nniPleRAI8cFuobGV30CZo5no708u7DGkan/mRl/UcpSLzao2QKoFcQv39CCNnHna5cZXKzllz+WtfSJtER3+sdTClGTQZES9lm+RARW/edfIgrcAJwHCbVXmxju3XrsKc69Hi0MWcnvP4kXg5RgXyYfoIjTR27VsNFnvAjxtwTZKYbC2A074YDt8pdWN5WjWPQQN70uwVDPLmQNGb0C8E4s+LMmQ8GCkuqwB9EmMqLwzccZ+04XxpJpZxipQoqbHsKL5Q+BFBNGVl5V/2QQqnzyDWfKHMGNJh3Ni87fujxxyzN3sNVYiLvcr938RH8KdTrBiVLFnsT69i1r8ngmUdvd852/Q+PdBer06BV8EfR21FAmJrm6EcCdcBy3xwPZQCewI8FCIFOT4yjCBa+5tGfFmIiwr/36puSxHKYDHzl0FZ8AANMWF2+V8sCVFZEr0vN+OdN+Vs5lVZZUrHwf4rz10sjlT17JKPsdkb1QNkckqIX1pIQIUTTStWLP+8MQTKeP6nVCwy8FPcxEFKyANRvoR0S/+aQU8ndlH/f6pogSLrmiNEHmXRXeOpMGtCEiP5c2jajkk7LHdS7MIQN4+g6S8FBG5VFUTMZ+UpR3/rgvYsqepBoWWClFHMcc4mhrL2/5DSZYU/nfvK6Xc/UdkTBapg8RkE8UcJ3nL6avNoQI0E/CcFPn0/RfylZQgkClziJENvIsIMAWLm+PRHTTjkIyfL+noSBS/0cdQpA61quwzccZ+0XQhd4ph9i6UUog5IFYlFNTBFYW9ldUVlVD0zs9GqaAz9QJNs43iKsf3WhwyCQ42toYmG/eaE37k8oZNzbSDdxUWJM6zTCcAD66GUjxDh1/TDutkH5PDBE75iDIqsMzeWjlDAWt1h3OcNPMU8fstyIF1Q6PbX6GUm+5dG8QyNldt2+9nXCzDvAEiWi35UpCQI009cYVToVEV2Vd+z31qUTPU6KjkdbO4yqc4r6ZYokp8YtIOukfArROfIunehs4QIHY6jYIYyl4bjEAB0dBQqNGdGoA3gmEUO0BdI7lA83jur4Akum6ikk/Ec8D+z/oNB15ptPthgNTIyL8qRPPF8mo9rKDxDVIY9K+h2bRCdUCEoHEB9D1mxRFRCgfM6AojtcVTm0O7EvhqfcqrMsj6fU4jNnfvLTU+kUbybXqBBiSpIyQhZ4p0FavdsMKLlzBctIp4YJai9FQwENim7GQIHAkcBPFumQNEy2IGQ1vvX16EeoWVmydA5UntX+rlJ6YaT0VZ6+o2RnjkdWbC5FYlFNNjpmMkUtRBFGWP+asie7EX5WNJh0DDuxgPnsvzbWNM1iLCWVcOAT8FS7+2LjAjBLH8AQznGJcDKtlEMtd8MLiQfXb6erPAJ48AveIxQ1zeWjlB9Wt1h3OcNPMU8f5x0pAc/4F+qQBQX+nd3yPXsgdNNX/6fOiQKTCy7s+lpsB9lYWVpZXnZ1XVwHdK+POb5E05At8kdfKfifaL3vZNhj/GVgWOv7xVaZE2A/bOtWZ/1FY68VQd+8ALqFTDGi1R71Tcrw3epdVR0YQrw4u9C06qjkHUTm58RbllIqYqup7IRG5X90i3EVGIyJbuolYT4qpRrWFN+1Px5BMq6+RCxSBAJWGUkRLBBXW/mkwgcncAYcED7YG7MtgOPmbfwmoGLVMnxjdKC6R1Mex7rXq9Ij1FdNR2J0iKBag4RSL0p/CdlMmb13pjdBRJEMk7LBSZqAgawPFumQNDrxM6s7suX16BXOR/DceAQCmuTHwlJ/Z3y1XNcHvskntlsIqXBRYlMbAko1TVE5X/YVW3uxyjykDiw0YssF+VKsuM+GnQvI11BaK8nwe4MNyFLjKcyaDiMCTE5Q6yzH/mCwpQAvtmpL/VX0tnOnSBBO8EKT+c2AlwSbyokEbZN5N2FPKkLQdI8jSONZUO8qTV+ThYelR9d28Ng37kuC9TOCD9OfZkl1A5IBQV6LXEMQERl+rZfJ2bdEPRAo86haM4ykq0vsZMRpiSpmPvqeuVbMQr2q/bxNN9E3LlDHW1mlPvPAAD3fP6zVHYT5BPBxB68YSJ5I6ED37hKGD/uw/TRxzpBzNfnooNEDvptVx+gNOMGO8uZh2XexiFKRHYCSNMER2LlxQDETA6hRVFoKO/FWUBfgyZsbr8wrG7j3CmtohbqCtuB49j00MSQPfrimXfJYeG8YeBBmQQV7Xt2GmI/oeYhJTqJoDctB8rY4ai9YUgYWrnKESJH+zI54RPzDZiK1ATEMtfPYnA4YBRW8uW2M7Z8GrjwN1qeCS2d4jIl5flUddCIFA5IZGVBVGVttWFBDW4+fnHulBTlQOIt+MCmxfLjgwz7FYslpMXmvvK6kjRH8+MPuAiwcEn2YokiArniH6AA6v7ELk6rEcneb3RkX85q31Kg2t2ucjEUWiZoh2IRPS8nV/O4gRsVEF3miD5iZ8xfk1iYigcBU8QfA7TvERWrpZl9zQR9JQ9lXGWMZOoUQdKeI3q9V+BQtwBljMOmfcLSoIN9ldSloP077kTCc4vJaiatMHAJRY6DUStCyOrip0pC2WlfVCxi5FLokEo+WD1U78AXKw0bVBk4vzXswlpw5NfnooNED5UwWa4EMAP+JneodZHewpBr+AsCYMZUA3I2vQCtAGpV3SoAZPV6UWmvgfM5eaABlGWDT2XNhu+ncbfJr7yqBMSAiwb4qCc/o7CrXq9IjA7NtZMNTi4Rcz1oFZLQbAs9A/qx4bmpQTx5QkHHXC2SUgcJPDK0fNDqTTmFI7Pevk5PAQBWmqz2M71rOcDkAO1X2Xgw+7Ihf86JDqXBVMUEIFEFLEB/mC8tVELyxnDqITkdHJZxU1jKi6uiehnDENM1iLCWVhbIL8FDrVNXeCy2UGCkC6/8Brn7Sl9ExwmROkAnVg6DpQo2T9APH+dtSzeuXlEdWqNAl+JtAZ83avN8BB2VOU20zCATIy13e0mJ9eskMxAmB9S3ERXz53EA5FQ5I0/s1US6GWFwC9b8IOewIFidty5smLO8afYSkYY66lQBn1vT8eBuZR4tuo4tE1kAULFPDCczzNvPQWGS6OQHCFtHjAOUdAVOLFtI7zWv0juvCD/Sd6GleyQgdD4uhmsEI5U6UgbAECM74naQpLBjz96q4CsKSJxQG+P55QmYPTUQYGRQHQoARFRCgfJobfRVrVTmFXodoaq7mtu2//8S1OTYdfqv6Ut1ex7rXq9IjA/ErV2ILnL1urMVMGeAlBsQZ7PpDqCFVYsYQkHHRDMa+cZY+WLmYPTq3UTELreeMmQLAXkCwaERz71rOcDlnNf0TVZs+oYU76AZxqWofIQQFDU2QV9swDRF6HrrszjejFTk2JxhR1iC9uLD/hiKB1sEsJ8nwgfEHlBHuZ0jbQ8YCUWIQ694MxHbck99vw5hLmRbTtkzkPE5djEKRIxRAzcuclAgGeJosOglO4Aif7h8UFM6FQ4G9FUmlhYelPTIiwwI0ikvAiXuLRXfc4lQoBF2M+9/LUC2ESW5QcLj00exR0ox986pj3Piseefs2Iooomxp1vP9xRG1Ur2hoPdQ0pJ0+mvGChyl4bjEACjdWlfVTdGmU0pdFkvZA2w2o5aDw0f4A90c5yERlldoSPup7IRG5UgEdKQ3BM+1kchcM83z96q4WxD23x5L4e2fVnYCGUo4WFR1YDxRFRCgfM5er9EcXT3JH7Nha4els0245WmELWwnhvrLXc9Rx7rXq9IjA6A6RNNKoYtcvMoBMutbHLcPp0NRqDoVFs6CkHuUB27OrJQpVPzY2Wj+AGN7bqCI6E+BA5fDwEkM71rOsiJ5Z3PRTcdUpZAiflUdbC5MSUFNRTtmVVpcEEVQQbjXyyujFH5v1stRM8XxuOz7hiKB1sEsJ8nwgfEP7k8t4dbqQzZQGCoEi6zJwm37lk/9snAX/RrEhAXqPE5djELW1MUCzhf9lAFXdZUlMgU+4l7gt10ADdVKQ3n9QFK8nhelPWJ/f1Z3yAfAkTSUCmmpIQVrXj2MER9ZGW/EVEZEfr7UJ0xs2AYlkRYyP4bts0jj0tQdyC2n4ruftk0ZUPEume2COooeY6CGChyl4biIRTDnMAiBGxDaLqggHV3OCcgp6Fj0uqOCC9XwyGAejp/9Bquh5YRLypsWfOxJB1jKjuEc+7+zn5yW1ID21tFFPP5xRClFTQ/JSVo+PVVV+/LdxI/sdpgqVXi0KilvfPaxse15mHLBMWNfhfKtQ2/DgjiSeA2hQRR7SJ1Ll3Zje1kOTqJoTwVPp0NRdH9BFx5QjGmQPcfCuYJPHuXQKRHTTmFIbqCI6E+BS9XgfBRMohuDtTkJNa0AUwEOjMonzVQybH6XK5dZFAMZQQsw0TtVELyxnDrfQTkVYNsX3X8qf3vftWX3NOdqMTr9cq/OwBH8Z2ObOWZQGCoEi6ylcDKhkkR9x7MBlRvCc/Ht4Q2T/60ZZc1FnPDclEdWqNAlOcNPMU8fdI8NAIFFUOu6H6aIz24lNmt2wwI0ikvAiXKICo0hKAV8QUkMEVsVWCw00/24hZ3L2P1R4A1/dVcm3Kjtq4q8IMRooSZ8I+Lsc50mE+Iu/egCN5JRY68PR1veL0aBQmDnPpaYCt7ZU0pdVR0YQwE76E8M7LnATl0rzXwquAwwGK8g7IoPvptVv+RNTIyL8qRd1WPmlk35GMWVMg1M1fxCBWNBTUpRGR9Z+VVJRVXfqIkaoQNhHSGNF8pv6fncbbM5oDjPVWNnfvK6Xgw3dHySaRYjTBAqV+pL74RagKhAZPs0ZN9K/0MFbWdB+YhDiX4BPh8+tgECUenE0TrBCy1NvLXGopOBWl45f69UzMq3wyRdYafAGhdInZMzzVYdvjBKNB6NCUBAGUltQlVGEKTCnDqcEipXYIdG1m0th48efj+R3wQdI8nrfbU38VS7JxzUQ8YCUTJCnVaMsnqs8EYoqHFGyEaMuXrdPFUWjELFZc1UnNv6m9cfcYN5NZx02BufbMeRCIEDH4GkQUmRjYLlZSEbwsNIipKJiXa40mmhKAV8QUkMXVoNGS6TRUBRcZ3K4qIA+opq7Vcr3Nz7eefp2Y65/H1/JfS7vV0ZHLpukPdM19tVIlTDCcH/4eWWADm63GSVTdGmU0pdVV3WBwFyiBD3z+zVCjyb/Xof6QZbGqus7PBIllgGaO5ZTIGNjexcO8fzypX4CMW0NgMA1ussBTsQTRQDGUEKYBBYWmvgfM5er9EcVSn3CiMxabXmugo/yGTG4jsefubLXc9Rx7rXq9IjA6AnQMwS70xbxMEAHaI6HNpB/3sAqGRED25SpjqKFMPIaY62D0nAZyK2Gj/0bv706DruCoWwwEkM71rOcDlnPfnSWZxNpYdijlVHvHwMLRUVXWpVGVpcUodVX3neyDqvEiIRNZ5+1n8taq7ksj7BZcEtSXLvxvF4jRG7Kg3bQ8YCUSsW69XMsmvbklEjviFEyGXBtkGdPFUWjAq4CIRAzcuclEdWawok3J5p1p378dqLCcFKRbnOTUnJnhelPTIiws2K6/uT/TjWHB0hKAV8QUkMER9ZESB3U/wCffjL0exP4B5/lyVm3Kjtq4q8IMQlyC5oMev7dQjQXaZUlrYSZAsR+6ztChyl4bjEAGTn1QaWGgTnH1NbEFfZFN6skzv0jqiQTo+dlDQe/626D0z9m1Agplg2fPIEAcq68qQcM83zzpDkWxD21tFF4e2fVnYCGUo4WFR1QoARFRCppt5etjtXXWu0UygkxKGpcrhsnTzZ1zgagfbtUsQ1un++tldeDkoqHYtG6P/nhI9N+4cdQg6CmLg1tTFYGcVPyCbJTZ0XdNkCGeH2OT03Q8oFcajI89buIRj8wCEFjwbDsyo61rKSXwEPmZ555BFksjZW0UFHRTtmVVpcEF2ZU3jX6XuvQXsVOI5M1jWHuLjXvyOQOsImI7+bgbc4lXiu3MOpDi2SUSQQi/8+aVXH8Aw97SQ3/Q0BbSnd2QYW8AuUIt5JnIecyp9WfJ6oOgxBZQjcs2uXRtgNF2LsMEmA61jh+HZnhwJO8kuU9yKfDlHh0Vl5DR5IVFlXGWMZOmdYtb7m0rxKPRo59VdhB+i/eqrY2ZQliXdw1xv7f7LXE+57qZQO1kZRMFXFCcn9NOiNACenO9fIZ1GmGPxdHB0EQst7lA83/N4QTo+dzTQ6nUc9GLHp5MkG75tExKQHTML68qRh4zT8rBq4WxCWWOtJ3+pxUDNBBEo0GQQm+RBERVrgx16or8wA4luTVXMDa3ilv0A5yG3UJ8APfrqnXhkZgnq0coF7A6h9EM2Ho4QquMkSNaIKFw/PzMgRfiQQRJkCfyugQNKJaZQ2Vbr3NHjBAHoI5+80bWnBCoXxf5/MdwLmcHR6NbLAWx5U5Jt5855d5iFWH9cNJVdZV9l6VUMVRa+f8G7jQXQBYJIM1nm/f0jYxyKQ111jI8mvdqMQyUT64g4oBBpCUWJEm9fJrD+blFN97S92fEbAaRWdRpoFwUnRKIkvtZ+h6EcGaZ/z+NMXY978xh7Z0IELT4v9EVKJ81Kk+UkfgdI0komV9iKZRTHzA5V8QUlVQ6/FBj/WXVREovWJ+ewJ3pArjpZm20OGq4q8IMQlen2q1uP47kaZE+I7q0gCPn6e+6vG1Nv9MfTQACunNmOVCxazHP/rFEK2EZF8nAn0/en3AVPr5mRl/Uc7GL+giNAPmlpVlrxpTMCFjutcSXzi96D4FJK54tES2LkfQE/BTUovVp69+VF4URDCwswGr5JdGjCZGyM7fPenc3NG7j+UO7IoxvLnCwwZxy8Hd5s7D/EjWMMLmLxvxMFSJ+YhA2sPrqVRd7kVWMxarnKEQNKJaYA2W47F2ifXQTFCdcv7nAPVCl0gfAQY7YWOt8lqH++SXZM0kKIa5BUddGgQLUEDXREUBmNwEBEVXPndnHWxQSBVLssS1m+duPSknSDENJQgYmmexrcNdoG7Iw3jFjYCQWIYnACYaX0Hu56rd65I/TSHto8BPBoFjAP4ItEOmw3h55gCcZcfNcM03QjldPPAAdR0UO4sAprJ8YffQDJbcZJP/obAy8jPByjt0Ut7FQQDXmMZGW/4VoVEd+iI4qQU1BAnz5tfNbPaqYC/INQh/D/8Yb+7ukHXE3Quj1NMN56YSDuKTsilOf8BUCGdOADSTdykU+YdHF7MQwpd6E4+juGZHEKklDoklkUoA0S95YR15QoUv35EHciL9chcMyHvllb5FdGN1x2FNKkhBXNBRQI+CBAQQmxZHoClg1UjslppWGiWUygkxKGpcrhsnTzZ1zgagfbtUsQ1un++tldeDkoqHYtG6P/nhI9N+4cdQg6CmLg1tTFYGcVPyCbJTZ0XdNkCGem+PRHgRmsI7vLBn6LEWU+ywE2FxbGGa8kTNa0AUwEOoYcn6pwrbHsRMQ5DClIXGRN5O8sZV3ixziPkF9IGNI9WPTbsaeiznSDEZdQsK8nbgKF2wROy3OrdQDYKI8ZCmlXOb8vbolElsmVOo90uzRig+FVG75q42qtTmh7ly55WecAwE2NPZBndfNqQFM6FUvztH5TGyPGy+WBbfNU08FOvciuLRVih3F1vDo9JQo/4V8tQWFsEaKbN+3/PPVcwdXUaP4zte+zv0wBLiTEi1q3IxVbQXaYBq4IHY5ICK/aR2MCfKbiNAHyY1UeGHgPfHb6fVRT2BwM7mWvolq4QL60t5ykk6pw8SLnajxQFnUwHfO1ZC2rY5PQiOojMi/fLWsOVPZYf4eBwVjMCTVEeGR/KOUJYWlTafMxdqoIfVjDTPDtgafLhvKB6/HHQ4nBepI7wV2/pxyqFcpo7RpN7Vt/Z7ZYpxt6FJ0p7QJVFnJ/edH9BFxtKiyXeAsSVt2ANFvHfNDr+CTEKbvTApQ7BCUHedQ6O7YeCwi5nN3DTVhp45q2Y8QBxbH6XK5dZMkNWV/VwU6EIOuyxyWadWWhBMwIRNH7/aaWlsFbG3ctmYmD87IsXloHDKd4tCi6WFDAQpET0cDCclE9uqCJA/UXIzXqp3QEW7BDY0NAakIvwzQBYqIBz1wl0MVXfssiKB2VCWr3OTUmVnbCe1i1ivhpoikvAiXLBRWzt06lpFRdFXkhZGp24XkAS9b8IZexn165/jp2m20OGq4q8IMQl/DptPLyjdpv+R+IwgPEP1pBRGRDWW1CfKbi1AByYWl+4TfCmA3gkGlK2EJF9noK0zfbCD9aqi8QojzU0BLb97NQUnEVBkrU4Ht7S8vRq3iyneVfTHdjYPJVF445kLjNBC6g3TE9ZYVcSVFik/h/wfAB9K7KJH8AmfP8rbbs87iuXP82nhx76Xc9RhnqLxEJXUAM8SY6GnKRag1JVKqIwTw6RfeNRqDoVFx5QjGmQPcfWrJlKWO8Q0DrsMTE0qeiBopyNRFrwj8NMngyLsXYnJxnSGcc+72lrilV2vywEO9dZAjgVUExcO6EVG0D6h6GnSmllYItNO80gf3aewWbWNN5jMC+guKFVlDrIZcLvQzZQGCoEbU4AwnqskFIsqCUolAOEa6Tn+FVO7lKMCIRAkgOr6Ed3dZF9OhM23A+r8diIAdoOWaj9FRbAh+Sh3GYictBS9Qea9TrSEUOoZ/F8XG2MEU/LUC2E0//ZfumI+b5I1pE496EyUx45bKa81hoeppAqOeyji6+XR+Ijq0gCYVAQM6DWW1CfKgLIST3zD540GbrZW0YdWBqVTgpq7UjWkaD2Q6roiT9ji9IdR44c6Y/L8AYYwK/AQYTG5a9pPmvuyo0SVhiQ4doIM4U/CGgMQEE1FBQUZBl1GBjlg1UjslpcXjyo2Xsnu+GpcrhsnTzZ1zgagfbtUsQ1un++tldeDkoqHYtG6P/nhI9N+4cdQg6CmLg1tTFYGcVPyCbJTZ0XdNkCGeH2OT03Q8oFcajF7UrMCob58z2E5dqqcF/BWf0UVIk+pgIa9RBxrXoMLAd3TF6XGUl6VRFrQP7fziexPDlYLgU3Ni+swuTRnS8ONPloYn+7gfEL5EHyKbnjRXEOUWVR8pqMuCbabQo97XYJfEbIhFHx2BAW8BqBZhQPi2vh65wEg2B73xEG1AvjsY8NCIFYVr0lCEC8nhel4Homwr91y73A/CHBEXScKFEfEQ6MX/dZTSFVEVBIf0vN+O9I16srjkVfUx39sarK0tR5iDw8I0PtcRfBE3ks/alN3kIEN/HSQt+fLOGEVnHnIpqGGgPfEr5dAVf2QtVekAW0/0qQNHX3zXwau9c7Bav9pMUSvptVv3E0C2rS8ukmZyLlikf0EdGJNdEG1eVhUD1AGQV3Vo/RKEMRRkXvqYRqr6V9BSX0JHQglKmds+15mGD1O8EiuOimGsARgiiSeBt1A/F7Rt2ZpLUcx1EAL0ooH2YA94ZRcHlGFxp0pW3EOgn05NAOR0nH1X34QTEdtuy06BTER/uahRgMiYPLcHNi1rKSXZAI5J9i5A/kszdqYlFNGk6NUR96VUVQQq+q8XXaDz5GYJhRJTHahaOjwzfQZgRiITjbfvE38RHjYcKbFzcSFGJ1pkiMrHbtn9R9wDACpAuBaoTv3R94kG7RIxQGjwzlyAZCaYRo+NM4YpGlwMHKAYFEUfyyA5HZysvk+XshfMEXioaUyymBTmXSA/EfEQ6MGWYVGRYZEVBIf0uIJwBBPQ/5q79nKu3tcLWiIMpb/Dtz1x8pcB+TXfJ7j4xH05J0+oCLFYyd3KvIAGOk3EeQFgH63epdCR+cI2gtkoSBjuS3Go+om8QmkA5cSLObiIkGoFNFbhgyGNC0naQf1m4/iV+SGdfZ1soqPP55DjMtA5JQXR/hGX94FRvppt5eg9F3JnWPXmpbu+Sfrrd5piW24nYvrqCLXc/Nx98kcponA6h9EIFK701pxM/BKuZoRJVI5LMSdiEYVgYG9SvOQIXEhNBFHg0QNG4TLF1Jten76E02Ci0KeAIDjxfOritnMO3SWJAXmZpd6UUjbCcEYpICAVoYVkkDEBFJENvJyF0kEz9fLw5+1m4uuLvfhjOL329bLT0AxvFXloHD3d4nCiVDBSsGppqPxTGrlEdjd6AbaEHBrV7WPFU3l9La01xFzgWelBs3bYNoOgAA4AvmqtyQC2NYF38jCEm28sj53HYiecp0/5yP9TOVDHOjJ5VwSG2MERETMj9QTRVmkKzYI0wJO6R5k9Fm4bb/q4H8JhUlkmArPfqtgVaUDfItk0hB3Ud1IkeCIYylIbiyYTS7PR3PTdzlELpoSo04AJ57opaW/en3Co+jlDNflpobB03ootBG8BUVurZNDd+GpeVm26jz9944O4C1OgN4PPcwBSAOAAFQVklZYoAWVoDfwhVjbpcgVWiFXisaeKnibbR7mTTXMChavbm/229Ra7qlmQ2y09s7Fd1LnutnxMVOIPJeTwINp4A3dXEUWJoCyDnERcu+qwdCWaj31BHTTjkIzYPNkTS0CoLxwAhDoI0Pry9nP++VW2dZmgAa5AshbCU0YlYPTFJWVFQxX/UaELzlnF8WCGhB3ssYMy8rhaCjxzfANN5jMC0vuec4i/C7ZcesF8ZBH7c2olXNiyas6AwsjHFOyUXBpoDr0oBEjCP6ShwA92PXlEd3ssBD4sM+Y5if7dXFFxFxX38jQpaG8dql4HorjgJS9QyUzDOFRXObKHh7DoQoEV6VV72VHRVDcr7J+LxV1/UqzQtnM3OGq4q8IMRkjydvPLeyg6vLE4BrpbtQ3AIFOlDDBYzHNvDNTCW5PR3ZTg0jU3/qEB+8Bcg96FfFjxKsTkan5jBb95toBemppsEVkSEVv+RNTPKOp0JAPD3tzmH4Wsm2E+pE0JsyQSY5AoULGVBXPRBSW/ilvYZa9EEcCWChO6p3iryth3Nw7zCUPCpawbPqGc91qCq3dBYjQRhqX12Fm2gae25ABgdpHqYA64YncHlHDN5WizyBDwqXhcAGWO8Q2iS3AyAGqsvI6BvB+HH5hpQY9dqHrz9n2Oy4VwhUoP2npR9dzlZQL5MIHykYQQNwWVcBEPvy6X0eDi/aYNtD1oqDb4CgwyL3NNloNiKwe3pSzFazAZ3bH8Z6I822yAqAr7qsoldwqmAAlWXBtpjdXnFT75bLItlOmcvbypJ0aZgpE2NPOULf6MDBRt2EW3XuG5XH8Ifi1yckeco+7oXS8yKAFiyhZ9xiQR9JQ9k1XW/ZXoVZfv3E3rhI16srdVcmJKiPmvbo+Ywm8ydpJu8ueo8ZHLpupaEJ1loRL/yVXhziMKDJQSvjWlfVEdHQIr6cBpmYR2A7opaW/en3Co+om8Qd99ccA+z97M1JmEZUgbByTIzX8w2N4zLk7BqYGhC3PYpI40ZtBWg4TUsQGVVQO9QRV/alwY/kaztcVWDRV//Sh3ywbeB//UqRMCVnv+Kd229RpUy3dAYjC6JrEOVrgwIMvNUA0JEDCdFPn2YyaWgVBsFLzA7rSJH+ygUMVbzD1Tq0J8E1tuyGmlbBXFCwgppC7YTArGQn1PTTW2dOnJ6n96FwqGkLNlY3TFJWXVowUUUVU0z/6iXkDHIHMJMWMFKsuLjqryCBOJQxJyKwhbdR/9W732LqFicQFGJEm9fJt8C6nEdmrmdJ/QzUaRLx2RwY7lLF0YQCisvsypNPdZcz+gtG190f6djrRxELRbmkGAX08xfb+GF8wtZTz/uN98nOCHOv3ElvA9lFXlwNWC2TVEYQe+CJ0exW3FUry6xi3Oq8eart2ZYlpDxpJrS7vk0mOaZnoasC3ll4LRC0IYylNvPQK9faP5uAAhSmB3VtEB+vJbBXeTLbqqiNTlXk/ohell1eSJzajtFGokg0fqAEAd3Y8qoMImfx96HW1ID2JIAJPKwsUTYTAkYRVFZXJ6A1CoDlwhZlr6FdBmO3DV/hu4udsbMxj7vJ2zNxfrarEZYRdzuFeQ29A/odEIgGouxpeY93ZLdbANwP94IDei9HHc6P8nLJDcWVaYAORObVZ6HTTj1JsqDOoQaNERX9fpMD7ZqPwzgiZYnSGh90mNlo7Qwmvjl4YppCA/hZSV5eQkRHELTjnH0kDiJVMJxNIDiauLD/hjjL3ssaMmOhd3QNdoG7420nQy2WL7c4kVajrmGrpRw9qmhAj9bRd5Pq3Q1WkVnR0dtOkNvs9RkFbYI3OcMZ1ATfq1yUXIEDQ30qCAKJowDl1HkgfZt0l9SA7TjKAHLh3EQoE553ERQHGSR4XkxQf+z++PdTFkV58Rha3KWnxaLgIJFfiSs8Ivqpd6vLE+dk/aMN3EkRM/HUWMnz4bC+ACzcPpGVHhD6Aq/r4o0YFNBr6AHV5b4QGkyi/Xxe5pg8Geb7xxRGklwZv3ECCwPLjewlZ84jllzMHcLi1tET40QxR7tAHkYRTVZSLFhRGAfgqI2papdcBSGJDDYv6fncdb95vjTAN7pdvbf6GYo4hXa3dQo/A/9TAxZKoeBavdsMKLlzBctInLkRs8VaFs5UlGfEBNK2sIRVFqW3YDrDDzM0qfKIno0VQ/uy89kMihuCcHNy3rTXS+AWpYVxpQonuC6VI6M3CUMZV99cWVg0OuyxyyujQXMALZ9+IWKsg4OqhiCFZt1fMXK/dqUW//bIKg4xAixCA822yAqAr7qskEEjxTQ1/QCRgo8m1ydWjBTQ0xQUix7pn9c4dxQl+gI2Y5jxdM4UEt6EWhP6Ap78h1Oe3W2ehgJn9QeF8nKTAG8hNQUpFRdZU9lmMj9QXVBEr0vN3LxEZQUnjlVmLPTdbPr9IIUlzyd91v0ud5qZHLpuya/ON9NYY/X3Wcql1qOEQWTqWlfVTdHkBPIdEF7OQsQ77VfojqiQTo+dyXVq9A1oD4vyp2AOvptVv+RNTNXLfhJdYD4b960B1ID21tFFPP5xBWMsBBcFFk2NIRBUWl+gtOIer9EcVWCHXoY0hrLrubNuoDzKVWNnfvK6Xc9Rx7q1/G5jA6lyRIZIou9nuMwEZKAlHdAG9aYVqDQQWIgC7nLJDcWVaZpGR38ZNDOQTnsIseaGnl0CRF89gQMI5MrUcHBc33zSSghIlg55pV5WbC5FYplIGBFUV/ldXFQVYuyknDPtAHFVMwhOJ8Haf4yebSCjU3UKC5CPov649FbIKg3bQywHBWJ4k9eHcAismUgOdyFO/QOEgkHr3RYWzpi10dUOicvhy69WacAwE2NPMU8fdMXFEtJDF3v9G5X25fTlPTIiwwJHimynzC0BADmkN7c8QUkMER9ZGW9QQkBEeLvGOeIEZQUnjoxcLviwsNH8IMQl/Hda1xyAfBG2E+wx6uJC2RBYY6jYIYyl4bjEAGTn1UeWAImbEPJhVVOWFJF6/UCFoODQCUPnlGpvllIqYqup7IRG5QtVv+QOAdSGmewgM8ab5oqFQICYPJ2MPLtfLjNBTUpRGUUZCyZQXFngg2YRr9EcVWD0XiNhu3udtvdKoDSU4jNnsvLCPJF3eX8Sq9wkEkk7UgQC74/6ohQAZPJoTwVPp0MScHM+RZkCzWHLD2+0tgRPUaKGNH8CR8FAr0aFnQ4PToXtf6sMnszHi8lnNf+SGhN+hepzuAwquE2LIARNDoEUBmNwEBEVELyxnDrfAG9vLZQMJp47hqfbhn7H3c9nI8nrxrQR8oH6IujbQ8YCUWJM6z89sSbOnlQ69mdX/UL4zVGdPFUWjEKRIxQNjxuctp2Xesgi2J1KMQzlv+KERxELF+yhTSatwO7H3GMigZIWpXCAiXLBRTmhKAV8BAIKEQ1HGSw4XF6RcfmI4qQXPRZKjkcm3Kjth4rATYV9cmAyNhyvhAiZUvIz7ZRCN5JRY6CGChylMvmUAA3fMBn0DIeiFLplF/fZEJF68Wv0jqiQTo05lF24z56hHPuc/vgG5QtVv+RNTIyLivZn3HL/o6r0Ed3UJrsFPP5xBWM2TScaTFR0LEJcVE7gg2YRr9EcVWD0XiNhu4mqsK//6jCUMTYavO4mIJVQb5GXq9IjA/EbEOV/iL9cvNYA+3o0TwVPp0NRqDoVFx5Qiz8BAda+thUCVPzCH8qTTmFIbvnIgmXUR6W9rz2M71rOcDlnNf+SShlVnw5o/UVquWUqYlFNTBEZRR9KZFRHX0y/k6GfQTkVYNs41i7saOblvWWHYJQuJ7Cy7KF4jRHuZ0jbQ8YCE7k2nluHtHbxn/Z9tVs9/UbNc5Wd4ow0/QP4ZxQSixrxzRkTbNAd3NNVMQWkqt3EB1gGWO8vCUWJlYfg1yohwtJ+8QyF8iL10mmhKAU5D5ABUF22GTsVQEBZffjMOdEdPRZKdRxcPI3Gs4H8RhFflSl7JvPtg/b+XrczkqAGZQIQLFSGQt39KuyXDzTh3GSaAxeiBPBgVXG2DNRpoRT3jrDQHELr6X2qbWUoSLW5m1wGglgUaYgyTIyD6PRU4G4mo6r1EtGPMhIR3+weCjNLRGYeGR/VLEQRVFmwxI/gaoUcSEu0XiNhfbXmtu2/oEbTHzRwfvXDWKQe7CrXs95j+odjV1FOjaQfs2RSI+E7BcxB9ukRs8VaPN6CzS7EOcWyaZ91Fr7Y1Tr2GypKqfKInpCBXVTeeQpOoYe2cHRdNaXRVId48sl46A6mtXJENp5CA6FNWFItQoFFXP7u8TqkFi5HYIdXN/KsuLiehiCF41ZaGHv9uvEMlGnrKdDjBjRHUR/DbpqAwibgmEV9xT5UlEbRd5Pc1RBCyRC2IsMIlwzklBkTdZFc2YBP3AWvqMHHDcUFF+OsZj+JndKo+TJndNNJipKApHK9MijvKFkJQUlAVElZXCw4XlZEr+PIJux9X6xr7AsmMh3Gq4rqZZAlk8Yi1q3IxVaZE3R7j41W1pIvY5C2Cg8lAt3rAGSbNBvVBxayLq/9BUTYWJFun6S0kbPQRkan6D5ez5F/Q4vklNQU5Ug0aO/NU+PL8qQc2Heb5BqXHNWT1x5L+I2sXTMTTQIRFA1m+RARFRCgwY/ur5RuFDL0VmUohbXwqrMx9WSU0jMdhfr6VNIex7rXq9IjToAnEMNIouxtrYRCL+Z0TwVPp0we/8oVHsJCdziJD2vUrYNBFu0ZH6HTTilNuqDLk5PVCkCwrUlqbhe+cH5YNf03Xxs+pgde8pEddGtU0lEOX65ZBB9K1/60VLy57nvjQXgH+4F41mTxbLjhxG7L3d1fYivwtfk4z5OuKhvbIVVKH7kDpprBsje66ENjbksO/QOEgkHa4QF0/oHF01xDisvblFIWieF5Vwp1ZS3ltdjEB+tLF3X6GUmK8tGn0y2zwsE0p/u8rBjyNyzwKEZJQUlAVElZW7RRQVZ4a+jL1atTPRZ5o/dQF3mdiuSyZ+2dkSk8M1CIxVbVVPYukPEP3lM4J6C1CdCfKbjJHzSePovVDIebHPknER+2DMRq6FjojqiQTkDk7CYejp/9Bqv8m15A5UUVwLwyTIyL8qQc4i0j9/7NHcT23x5L+I2sXTMTTQIYGRISQoARFRCgfIJrfRUcN5++F8chwv3XbbM5oDSULnIufvvLXc9Rx7rXq9JeQpF7UdRCoeBag22FKLRoAJVFneMCbXATFsAMz8ONSZqRcqwPFumQNDqTTipJvqDLopeORE0twEU4mI4IcHMnP+nSSJxWosldnEUidpIFYlFNTBEZGVQxQBFWU3j/6j8rDyMWJ2sXIDi6fujkf7DPPegaYiLvxvF4jVm83g4cBi/EA72B65P+tTOu6EgsdywFqlaBtkGdPFUW964C2xQ8cwrstpBSb0FfYsNEOzLfdI7ERxELF3T/HUmK6tb94ykmhcFTy57AyDfRDXjf0VFJQUkMER9ZEEMQERUQtML7OexN3AF5zBAbN3m7b4qgIIkfpHd5P+4qhBG2E32/pqNCKn6RY6CGSM+gMvmKRGT7WjSVTdzgU2krFkbMENBpiUDS/KjFGo0q6GZb95J7Rquf5+gt5QsZePBNB130jfAcKD4niVC+FICROgIRPLkzUCgBUGYRGR9ZJV/CQRDhwJ6mbpNhAUuoG8ld6h+kd3NH5XuRLSIzw4DnXgZXxyiWd5snA65tQNN47+1uqdFBK+FaTwcGfg91di5AWwkCcz4KB1z0vZUgVaCZ1DqOTjI1vKXLlGnuCoXzcA5C7+iLsW9YH++SVgxO5J9e65oxbDIFIA9MH6F1Vlp9EApaELyxnHimDiQBJ2t91ibdvf0egDLDNO/VSXLverQLjVDz0cevCjBHL7kA66GJsm3tk5A6qCQD/VLutkGdPBN4/5qFZhQezcijkkQWrclmOfg/Gl8fqMiQRto3W4isHQDA7Mb52GRnj2kLilCAy8vAFmncZ/ArQVBzER9ZGScZXkoEaO7mOekLO9g5iFBl3NCG/aq80IF5/DAsNgXzfB7QR+Io/alK2kBRL/yVXhzoM08JAHyY1UfVThmnA0plElOWQsI77Vf0x0fsR60hzXNn6jU0SPvdm2BGmkgYfbE4TJPLm0odYD4vjl7LWtWTJhoFI2IxBWNBApN4XFRJPU/rWVyvqM6adpZlAUuoXiMlfP7cvLZsoCfUPCtmrKLsFxwFxzeZfpdjHis7EIYLo0ltrYQIKv1dDNA2p0/0qHlRUwEWjHTBPcSKcNBFHLn3YX+RCzNIwrf76E+BCk8xcEkEmgeAcDVv3P0BFcdC72kaijddbC5FYlE6BUJNFkdzXFVvQqCq5GbfSXtALssXKiSshbinhjqEOYwVYiLvxvF4jRHfKa3bDWYCSi5QmSGJcHas6ABsd79BoRmBfirdPFUWlW7eIxRI92vJylcRbZgo+ZI02E7tt1TNAxFKRbDpBQHMyd3iPX2qctB38AyJ98nSSTnq0QU5AANMVkZLTTo3UEFVc0H7OewBPVUk7BwmO+iacL+m0IFz/H17Pf8ug5vWRPE7/a9Q2ld1IlKICajdNufEWSjiPQuGThCmHaNnWFbWCNR6lAyNyc4QTo+dlHNbyQw8C+fajx6GpkgBv4AFD2iLof1c4H8n9/u4CsKSMIlA1465QDEEQlp0EDMm+RB2UESgwg5exEFbHSGJXmYjbOGcgt95oDSUP71jxa0xCZoreXrXsU9jTpQrRMc0o0lduNBJMu1OA1V/feNRdH9BFx5Dpj4KEgqSqxNPDLnT4HvBTilBv+SB6FnBSFixc9lApJ8+cCAYNf+SGc6S6ckxjlVavn6/YlZESoEDAo9S0TtaELz98WbfAj51LJc43nndxLimuHDINMBs+yqvrKE19VDpKcqiEWICTE5Q65rJxGesgAAuxyFU8lbVxXrWPFV+yR+R2tESksuylAo3aYIl2gx1ZU7aqsiJRwp6F+z9TQuA9hed3j2gwtZ38R3AlGmuRTmhKAV8Do5BUkoLGWI0OoUQr38IObxAZFVxdVcm3Kjtq4q80YV9/Cd7IKatd/bNVPBz/eVJHAJRY6CGChylMvmUAC+yOALRTdyyFOgoVRmSQsgn6EvRjvzVHVrkb8QelldoSPP+7IRG5QIa5bEDCKP66qhcQzXqiEb+CNPT1tsMFsJ/S71UAQ9R+UsQJlQRCBDvqJwrbRUX4jD0CnxxfKmrqvkjoCzb4jNnfrqqCaMex7q0boYjUR9sRa/2nKZaqtFOMqIwTx6/p0NRqHlGRZlQoSKMUJqGhNAXFuuWNGPTUmE0qee38VjuCoWwwEVG7+8BrzsiZ4KSTg145J9ipS2ruWFPLUEEA/V1QR9SSGpVRP0x7TqbBDliMxhWOT+shP7swzmKNJgjSXLvxvETyEW71g38QzVHHmQQ7prYcHLsiAAsqFsO/UaBrkrdSQZTjAORZMlYiwec9pBYfwVz+JxA4l7wtdDBCdQFF+OsZlnJnhfk0zFncMY0kpKApXLTUmX8A5V8QUlAVElZWz9NEXZYbLuG3PITPVlD9oh62re8b0e8JhUm/HR8KrO7fBHmE+Iu/dlWZEt4JReLStKo4anEQleY1UeZCwWmA3gkGlKyFNBp6BP3/KqQFo+6b8Qellc9HLmxjcAUnEVSv+p3BM+1d+JdYD4kkkWJWs8UWOsFPLRsUWMRHpV4TWZ1MUBDFQvgqJFualFfVSH0UXMufOLubbhboDmT1jMmhfL9Bh/Dx7+Jq5ZgQQQqV16473/VeYQAZLQ9AJU16PlHqH/VGdZx9SKEQJq+tJE0V4TQ1TrEBzUAlPCI6E+BClzwpTtNjdqWcDAtH++SGcc+5NknpUVtvzFLNmh0DUMZS/pyR6FNOuyxnDrfQWFVB05QPSqguP0ee8erNJRaYiLvxvF4jUHpYsyvPXcMBWJ0uCGJcDOxlAAlxD5ApTCAgoeo2RZwyRuB1IR2t2uclEcGew/f0fpK+R7xjvKERtkOQ+yjCAbJzcnc1jZIgdZU96PDx8GOCHGgZ9F8E55CRo/+GXQfERUQr+WJ0a9JPRZ58BYyMI3tq4q84MRXd8hvPrvqqiXZE+Iu/egCN/1FJA8VXcrcM+vEA7KmOAKXZ1GmU0o5VXWdCcZulECWoN4QTo+dlDQelow/DrK8iNYPmlpVvbAECdC48NhcM83zm6rdNNWQMIQXUL/pBWg4ZlpRGR9Z+RARQETadJsqfA6mEzDZESYkebyq6Kc6yD+b4jNnfqf6PL2EejySeEIeHHs7EIYL74Rae2FUIrx7Gt1G8aRRqyIAWgxHpnCrQJq+aYoP21bF3Tq3URsIbqCI6E+BClDch/U4iZyHryxnN4XHVskp5NknpR9dzkoAMQoNQQdmGR/wEBEVELzcyHj7Ez9HKZUY1iugf3bjhQuENJRaPiKVxvoBdoG7Kg3bQ8YCASNCplX+cH3ck99vw5hNj5KMd6ahPAZT/6SRYYkvt2uc9QFSqIBz1wl0T6nmsdDQO1JEWOT/Ap7JzMrf+mJlwxdoikvAiTbAEXbpKEZ8F5QYWTMZGW9QTRVmnfj1OacBMEsKjkcm3Kjtq4r71JRhmXc6IKajcAjXEfJQ/bhQ4lpFHVHSRMScPJLBWDS51RiQAZ3mFLoB4o0YQwFb6CPf8wC4HELTyy2blppoR3T+7IRG5QtVv+QMHNzHkaQa1jPZikSMDqbSPIIAPq6TBTMTBAJFZ/6NJ/kYVzafwhVjbpcgVTO3ESVhevmAl3M5oDTI4pARxrirDJpRvz7Gt9JkEF67HZ5674RaeYQAZPIpHtUDzLNTaiQ+WYtH9p7EQJq+a2BPFumQTmrDHX5GuxaJlAyMQ/0WgpIBoIuAtDk61r8EGgoLzcl79ponuF2ENphABVJzW/Y9XVB0VLze8XXtQXgHYKZk1i7suOHe5EjFZP1pJm3LeP64kAbIKg3bQ8YCUWJRk/qFuXaqnUEldHEk/RvVcUyq+A24/5WRIO1Ijx8m9pBSb2IqOhY02kCwwNuNCMYLFb8vFEfJsvTlPTIibwJht6qQq8jFAFbp+V28A9kBDmMZGW9QERUQr+zY+aYYPV1sz5co3N+tfKb/OJ25o8YsN3v5p63YQfoxjPxHNB/RM/HUTt3yAKmUUC7u1UmWBhD6UeoHVUOMBI/9noLWzfyQTRGg9mMglpoMN2Dp7IRGiQsvv+/TZxyL8qQcM83zp9zWFNS7MgUK10Fu37AOAAFQVklZO/V4QoDfprIer5BmEWCLDTxjb2PbsKgs6XuQ4mAiwPS6HN9M7CrXq9JoUBhiQIZJmLMjxhRNJ+YnBwUMp3QYfHRaFs6C9XfEIazTtgRPHqaBODrQXT6Icbf76E+BCoWwwElLjhT0wDlfH++SGcc+5NknpUVtvzFLNmhZBVZRTWYvXkoYU43tnG8aDjsVIdw4DQ+serbbxzqEJZQBHV8vxvF4jRG7Kg3bFjJESSR4kE0IxHaqz6ggd810jlaEhFGoI/1WlBHZ02MamZrqlE2FbZg7MMJGMV8mjx7ERxELF+z9REmisYfj0i2jeZIKinTbciLBRTmhKAV8ERdFXlkzW7Z2XFR3a38A+PdP+kgol/dp+x3tq4q84MRXdRAFA+amxRmZHLpB/egCN5JRY6DBW1+6LbjMKzTn1UfVTdGmU0owAVDAE1VpmQe1jqbVAFCdm7xglmFPSL77m1UN5RxVkcwyTIyL8qQcM83z99rNEdfJDYIK10VwSn2BH5/4To/+QoARFRCgfM5etjtcVWD0AiMHu+G8l3M5oDSU4jNnrqDxEYkrczLQc6ZJQRhqX12Fm4QtvMwWZLF0TwVPp4Y4bBZaFs5OkH+EEMzTthQpVb743XKQMHIHseiJn5KBSBWl89kM71q3wyRdYcyTTgAXnZhN55wosW/LJlF2TFImMo/wXFRBEOjysi4mEz/VJJQ11jWHuLiehiCNZNEeHDOfdrlGjRPR0t+pFy/cHSsDl5zJ8ibwnlN98ks9/UbNc5Wd+BR2yULVZcQUlcvgyppWx4xlOcNPYQGvs1meBcF0W4C9TmaMzxC54H/nwJJ5ipuS/DnVOyWj4AUyBBlYWQIZXSZTEW5f9b8I2adVPQUn96EyBaagdhS50h/gkTEy1rLuepbMR+Io/blWZEt4JRzGAdjoLeyMAHenOADBRtHpU+EWVR0YQskylED4/0eQU8ndlDQellc6A+vkmPtHlVsZdKRPPdn+5KBnTXqqpUa2Wqqi1tFFPP5xBWMRBBoUXWZYOUB2TBCezhkvsBVdH7XZXp6Su+ncbbM5oDSU4mM5xbmkIJB4c7qTboJ7S9wIEIYL74RaeYQAZKIhHsALqqIBeHAMFsxQoGnGQODpa2BPFumQNDqTTmFIvvLBn6LbS9HzfQQPcx8BrXBm33KSWMRp5NknpUUdbC5FYlFNHENQVllWQlVHW43qnHLlEW5BSss41i7suLiehnCgHwRaYiLvxvF4wDr7Kg3bQ8Za3jIQ65qAr/Xs6AB9bysOb6bVb6mk0oRC9Qi4OIQOkNvm/QwSqIReOhAAYomftY8IDcJ4F4etA6aMndKo1iV8ewJS8FuL9mjWCo0hKAV8QUkMRVYZWnpQUEEQcK300ewQMkVvlyVm3KjtcLi8ZIF9pD280q37tFbNW32//axN2QIUL9PDIYyl4biUSTSiNTHUHgHaCLpbOVbLFwconoLPjPjuTlPx/7ox6okhBuip7t1JmFsUbbFPVhzPp01cTojM96rTHcT2IY9K+h2fUClbD5N1VF6XLRBYWlDtqM6aaoFwHWDG2XNhu+mvv+JpoDmELSxdqsimCw2rhWT+dpNhR/EuXsZ3i4QevNRULPs0ZNAB6Z/esDZVGcVPyCbJTZ0XdNkCGeH2OT03Q8oFcajF7UrMB679vUBB6M+DbTAaOvr4FsJX82BamE5ocSUI09oAQRpUFBR9HRpYH0T/oT+iTDBV+sJkWXCyuNvwxzKG42xhYn+7gfE1/9PyKcToDiRLHnNEnVy+byay8SwOq8Q+/Q7Td6PD4owEyUL+Iw/vzcukj9coewFjOh1H2E7wwNiAAdc4Eqv9D5P08xfi1yckeco+7oXS8ymBTmXSKAU9EppOEWI1TTAKEV64cf4INvRB1Bxr/Fd8O4aabKz3IMZzlStjIKS5xVqZVa2//bpHY/1DLBCLF+Pl4fuWQS0nC9qBFsrmHPNnG6+IAdNopRK0kbPQRkqmyytei/EoB0WbohQWpF/GePZETITV8u/n4H7zp/vNC1WPDdFHIrYkBjNFTQwEVo9R2phMHBClcrIer5ZqFCL0JHYtcL+csvor7mTEP8E6uaD1XcsXhjL0qEInA61iXxZNnLlmeY93TqJoC11O5eMvrW5MDN5PizmLQMr0uhMKRLm2K8r3AHdHbvDJk6XEWRW9r9lBoxXBcGkmZ4XXS+J+5whf85wqqSxFZlELGVdZW/EzXlJQELTjh8rfBzdUIst927mlsujjuGfLNMQbMSGqdKFSooHqZNyoQzZDAmFVkH+Jc8fgblluxSUoj5GCc/OdOFVQ8QnRYcAakwWr6DBZdwNoOcgRGl8fscuFBIFpEPicVlnBydGa3Hpivhp096XO9yqBSCLh4ExxBANMQV6LS7oCER5Or+WH24VB0RQn7Bx6B+jrdLvmItQp/D9jPOuqhAaZHLpB/ehFZEMTYzrDXcDr4e8KSTDnIQaHHIT6U0E7VVrXDNh7kAHJ707CTor7lH/lyQAoGLr7jdEUaAtXsewPTIiLnKFmM8bh8BL4Vgei1tEC0u/vBR6EGRULGUkWI/V4FUDhrwsbfDpcVnGVByFhv+meuvl56XuN4jgtpKK6GIsQhCqtroZqGFEiXtc47+Qbqc2FNxcoTNAA6eFRrDpTQgZCkGiCQJ0EkcBPU3fR28rxSzURhPD1npiERRW9r9lYoxDLr8k72qTBXxly5Ndo7QRrb75BYp1YA6F+UV5eEBpLOuyx6HerQXA+JIhTNy83uKDetHSWY21uSXLvxvETyEW732LvFjRMUXdQkEe2xSj8u5B9dyEClBqBrlb7IVpWoUKZPJw29qDclEdWdJV5OgUO3ATfeY8CBd6HPfz9TUmF8sul4ywhf1F3il3Ay8vOCzbcA5V8QUlAVElZWDkqXFwDeZ3H249EPU65z5tMN3LafYSt0x2oqyc81rurgAqZXONe/fNC3lMBSBCGChzhOuzECHut3EfITdzsTeUWVR0YQskylED+/KTQU60cyzlRlldoSL+kiIQDm9lVsKQIAda68qQcMyq8o6r1EtGP1soF4eBwVl/BTUpRVVoN+VRYU/ysfNUekAgmEEu0XiNhh3ywbfkk7X0RLRpbvav6Qs/aeWXS/EIjA/ErV2ILofEnudFSZOcoINxB6J/RqDoVWwlW9XHRDZqHa0hAWPyfNDqTTilNuqD1pRTMCp7wn5ICmOGOcH6d1f00V4V+5JEi/UVquHkBJ5dZTApZEVQzVERZV0z0nCGfMk59F0IsF6n9uPSknSDE4gQtNn3rgbdLdmqr0tObEX/OBDZZnUWJfVXs6Ep6wyEDj5rUaoSdTow+8R0Y01wA6svr6BkDahQ3OcNPMQGltdTRAtQLZr0xGB8A6MD3PTIiwsg37kuE/DWIETm/KHYtDA6MVVB3UDlfERUQr+SN0exP+B57y5lMNOmlq308UhsglXdsJf45gAjzX3Nmq0gCN5I2JlSGR2ngP+8WAHynA5HYCtHcBPFbEETnQwE76Am38qjDG/rdmTRIyAJlSKz/o+gG5QtVg3EZTNjOiL9cLm4ViV++WsSYIIoqPP6sSn2BBAIeGR9RJFcVQFmdfLslc6RwHCbVXj/hidyM8xwSxVC2VU/fhKKtUsQ1un++tldeDkoqHYtG6P/nhI9N+4cdQg6CmLg1tTFYGcVPyCbJTZ0XdNkCGeH2OT03Q8oFcajF7UrMB679vUBB6M+DbTAaOv+YEqVp7N2nw5BnqXwMIEEKH/B2UF1rEFJ+VPm9nG8nAGdQJNt2Ky8thPHetyWBZdAjLDnguKFVlDrIIgjbOXJHATZYbpqAwibgmEV9qCQDkpvTtoefPAZZ/B4F+dtOnNvs55BSfZNo4cMN+E7rrMjEFMRNUPq6ApaMhYelPXsfcsg396aO7TOVDHOjJ5UKFUlBREwNGSsVEVNZcfG14uZB06w58o1j3OubaL+rYZZy/CxpNff7goCLOfIu/a9Q2lYYLF3GRsnyKbiKTmDnMprVBxakGPJkAVOUGgF8nQLSy+74G9WclENbloslGfepiMpD5V6BaOAIAsiMi2hcM84/iVb+WtSSJYcF+L1xQSYRGQQRY/k1OURZFRrgb0Uir6JnVS3JH81ohbrcufZn7Xi+P81ir+L9CZo4xzLR/EIjA5UvVYZYi+EevMwUYfFoD2xL6LMBeyMRQgtHp7LFDwrTtgYGWPWE1Tr2GypKqfKInpCBWVDfdQEYjtWOa8QYH+fYGeYO5JAmzEVbqS6RKpRNDkBKXB9cWFBBEOj58TqxBHtQMwhRMDjsg4CuujWJ12xuI7+8e3c47UPs0dLcBjUxUWIQkUe4tSjtnAAjsnI0jRrSqkHb3RZX8RHUIsAIisvs9RkFbYIl3x2P3QzlsI8MBcILWPmxGQXZ6dql+yNrc050ikuPziKRBGfuYUt9QR9EVB/QVm/FRRVRe37A3qQFMkVxq6YyMO8bq+buZ1Rmo8hrPfqpxR+KE3Nzk41FYllEMRntChylMLbEVCniIprVBwKmFbggEFKXDgFun9DM9u7CC60xymRx6pB6SKvojs1Pmlp0xKQ9Axz4ouVwMyTypVeT1ID21wUN346yVn1EHloYVo/OIV/SXRDuuZsrc6VrVSGJGyMxabPguvB/5DT2LGMerPD9EgoHhjXDt9J/TVEkV+pL74QtxsZUZKYgCgUD7OAFemp+UN5QkHHRDMbJaZIKUPOC1TrQAHpYrfLBn5GBXkitfUNM5dK9iyFiYf0GXxpOagdm/QZlbHsRN5UIA9UZUF1gRUVGEPvy6X0eDi9GYMZk1i89hrjrsiPE+IwaDmrgcvdW8VTpKgahFi5CWSs3k/e2cGXslEdqsmcOjQ+Sgk7dMUtdjELS019NjwSg5lcKxsBY1xA0PpGrs2vETt23WfztD9nTndOe1ilig2kW96qOzXqBSCLSKAV8QQEJRR/QVm/FRRUNr0r1+4MP37xqySAaM4ehq0Ks1JF5/DYsWOv7xVbVVPYulrYS1lEFJkTgRNn5Le8QAHyY1UfVTdGmH4/xVU0YWJFqnpeUjvjRHUXg58QzlnZaHLb7jNYDkQVWgr9AD13P8v2n4zLnjkSRWtP2OhcqPP5xBWNBHo/4GU9ZIFgBQESTfM5er9EcCXe0LDYwxa8n6Kcw/jCUIikn6rqnCc2CeXyDq5FgTpE8QtM674Rae1kOTqJoTwUD6O2RbWQFUgtWkG0eAsfSqIYGW3eQKTrdBDENxvDNooLETjuzdR91iJbOqXMYNf+SGgM4kNlj6BVxtC5YYnlEHlUXVVpyVlV2EPnpzHegFX5RHgQKJn8hbLiphmHE42wVYiLvxrl+8RH8+MPuAiwcEn2YokiArniszSw9dyFO/UbkqQPg0pB+8EKZZNEOzcLllEII/sAlOcNPMU8fqMiQRsELDfywA5LGncfk0jFncJIGimPO7T3TFWfc4At5D5ABUF22GTwERFFVcemI3LxI1ic5jkcm3Kjtq+zj0tR9/DYsIuaj7kaZE+Iu/egC+6oREVXXB2jkNK7ERCG7JQ+aTdGmU0pdVR+EXJFRpRGV8uKqAkaq6DRymUc2A+z96s1JlkdVfrtAHM7ZnchcM83z96qW1ID21tEM1sIxBWNBDpBQW/JzKkcJ+/PjwZ6ffAQXVWD0XiNhw0GlbeBx7jPuMnx6qsixEYlex7rXq9IjURhqV2JDpLxh9tkTGfU8A2tIfeNRqDoVFsAnpjqKFJWJsZdY+3fF39SQAHpFreeM6AaPWlDcwA9JjZaGaTkoH++SGcc+5Jpo/RBcsF2HJ59MG/6WSmNwEBEVELzs9GqaAz9QJKQ2N8DtbqSltQuENJkj3F8vxv/VjWLi+NTeEWUMUW5ZuArJrDvg6FAurmd+o9a1tlCd2RtdjEL2ZcBAkxzflFIdqNAlOhA4YpGlwMfERPVDUKyyA58Mncjo3Hc9wsFU8Q8Fy70PRU7c3kEzBUkJVR/JWDsDVE2Dr+3GOedFPRpr7pxy3PeheeKsZg1f//V81rv7xVaR43shpeAO1lpWN/7GSM+gMvmKRD4e1U0gBwLyXaBgGkGMCwFun6DO8veZZR+dzXxRllcKSI8bjcEFp9gGbvQ2AdCFjv1c4jT69z0k1I8X1toIM4U/CGgMQEE1FBQUZBl1GBjlg1UjslppWGiWUygkxKGpcrhsnTzZ1zgagfbtUsQ1un++tldeDkoqHYtG6P/nhI9N+4cdQg6Cp0/Y/6Z2HN5/pjPAC2W2aYQHUenT3jzWTiIHseLBn54VRE4fwEUczMKAcD1eHYm3Xxs+kJ56/TwasiwAYl/ETApmGR9fVVJBW4+znDyLFH5GNJIQPX7duuimnSDENJQhMTOxi3IQ7kS7IcHuDDZRBT2UplX2cHLmu5B9dyFO/RbTaAXg4pEWlATE0IRI9supmzUWqNAlOcNPMUDpdOaBCMRZVPi6TQi071350iN/agJS9QuV7XmBTmXSKAV8QUkMER/VXDlQWFsAeLn0Of2BWoA68kE5O3Ddd0e8M2Q9/Gs8F+atgAjYR31/iqASYkZRKkftChyl4bjEAGTf3lenCxajAakxEB+ZENNulBL+7KTQHk4r5iFw5EEoQqP+7IRG5QtVv+QBC2iLm0sp4i0xk984RhCeNhARMvswSDMNCEpACQ9J+QMR1/XiuZwfe5QmF7bWE8Ijf+mls195oDSU4jNnfvvuXfkUdXbZq95aKFF7EIYL74Rar1FTMIlmDdEM70MCfG9RUgYW9WqKEMfOusAMW4G22XWXHBsIbqCI6E+IIRWwwEkFxdrOaR1YPfnSFsJX82BamE5ocSUI09oAQRpUFBR9HRpYH0T/oT+iTDBY02ZS4yW5x0Dje7iJOZ/n0yayufoSkBnqJwvmTmtPXGd27p+EbXL57Qk9bH69ql4Ltm0r4RF4/5WRW1AJiJOwuUcXdwQlQJl+4AvaxqWETqAZHK39RlW8h1Ko+TJ8hdFPxBeJz8rVOyKsZU1zElkEGB9EMj9QQ/BTe+GH20wDTAA/7AtfNbOtuay8KOhl/Hc8N088hnC+XqBr/eYEYloRMUTTTdnfKbjJH9en1UfVTdHlAakbVWi2Ft5h6AyV8qjAD9Tq/WZGllkkA0jgiIZG6QsTaOwNMdjCn0kwM8vhrBq4WxD21xYX40xx4zYVFFYRUF2N+UBQRlPdruUerAcxGCK3DQplePSabb155zH+4opdqba8GxsrezuPq9dxKFF7EIYL70MsuMYAHa1/FhcP7PlFqGpURItHpkbEQsWPtJIKRLeQMDrVGycI60e2nQTEWRW9rz2M71rOcDkb1qKSVwA3kZEipTYdgS6WNoMYDlUmGR/wEBEVELz66y8jFH9QYNMJM8SsabzrwjWKYJR/YpCPlcQjviTGIujbQ8YCUWIQ694MxHbwmU1swyFT/TnOa6SdQoF4ypqFCIRAzcuclEdWdJV5Ogl+4Avaxq4IBc9LCKyXA5HMnaGf+HckhdB99oqYciLBRTmhKAV8DQ5YEV2MVCsVQoUNrZrH2qcBQ6tk/6ljKx3tq4q8IMRoj8s8OfSIxVaZE+IujatWN/EFNkTDR2ilYrjMTSrjJALQTeKmSeoOMG3sKbNHhEz09ePfTo+dlDQe5okbHLbmiIROokg0v+oETITVwPQcM83z96q4Uxu2FYQL3+wwUSZBBAJBTElX+RxYPoCgfM5er9EcGSWPXmxja4ywvOMcoFLRP82dhx76Xc9Rx7rXq9IjURAqQMwO73VqaYQUZJUlANA25O1UnylZXgoMizmBPcbTrw90FsmfNDqTTmFIbqCI6BXAR9X/hUk2z2rOhDkV1r8XSZhOo+tm8QohczZQL5MIH6FgMo/wEBEVELyxnDqwAHAFLJg4Yz7cuKyefjnNZdBa+mS8eO5LyBHZKgD4RSlCVyMXyQrOgy8sbQ/sjHFO/UaBtkGdNVV4/z7RIxRAzcuclE11qLNd2Jp12E7wxMiHDd2CVvylDBe+8snyMmIcue50ikvAiXLBRXCc4AUkABdFUF2NSz/TEQ5Qpr704rtb3Bxzjoox3OftpPrv0rhl/Hc81rv7xRO1R+JxjPMP2lpVMRC0IYyl4bjEAGTn1UeDDwPfEPJxB6+eJs6/mRS0rs4QTo+dlDQelldoHur7p1UIkV5VntxYA1rOiJ6d+84GrBq4WxD21tFFPP6TBQAqGAFTXEtZFDxRFRCgfM5er56m4jD0XiNhu+ncdb95tHHHKjknhKrLXc9Rx7rXq9J7RpIj0dRKi01ie22UM0YlAMFP7PlBfW5GFwtNiGaFDsbJkcBPFumQNDLgTmFIbqz76E+IITb6u9kB6M+DbTAaOvr4FsJX82BamE5ocSUI09oAQRpUFBR9HRpYH0T/oT+iTDBY02ZS4yW5x0Dje7iJOZ/n0yayufoSkBnqJwvmTmtPXGI+8nG8aHXshkI/s85Al9bfhAToQVU3vVGYLIRK9qDXyAwCqIRo+I1pY6jidICNRwp6F+yiCAa25tGfPTBGdc2I7oPP9iLSRmmpA5V8QUlLQk60Z7w4QkAQt+f220xS+QA9y6Ey3KCn/aq8IMQl/D5oMf77j/vNSL5uiqAWN/IQMEPDW4Tl40eRTW0n2UeTGxbmLrcwGB0VXLt76EC0jqj1C9KdyXsa65NlSIyp/YQVkV/AfqByTIyL8qQcM84qiF7TDdSY1t9T40QxV81UCQ/4TR9D+WJlZGXQzvk4tjtcVWD0XiNhu3DhubNm9XzUYzMBw3a9XfZCcj+cq9IjA/F7V16P70loohQAZPJoTs9K/0MCfG9RUgYW9TbESN+VrYUDUen8NCHTPVQg8gyfhSKICkmy89kM71rOcGk53PLXWIs+7Jty8lUldS5I4WsNTBEZGR/wEB94ENfs6yexAG9QYJIRInigxuiof5uENJRaYiLvxrl+8RHuZ14uFzUCTGJjplu2by4H6AB9dyFO/UaBtpLc1QV+yUKAMwRA8cv+/QFTewF54vUO4QGbasqRChFuPfz9TUnJnhelPTJ9gccL9obAmGLRRS8hIE9vE6/MGVcQVnBEVBVur3aDPKFBO/6ypFcl++viq4moJdRJyXZJ1rv7xVaZE+I7/a1MHAJRY6CGChyl2b3EYnncP6iQTgL8FPckEkb0QtF8k6P37Ke3Tonkb8QelldoSPupoMES5VkUbblMAsjY8u1cLm42997+CabYPY2F4bMxRzMdTQV4Mo9Z+RARFRCgwIkqr5JnGCj+ET1uu0GXbbM5oDSU4jNnfqT5DZBQeHaEq7FFVoo71KpL74RaeYQAZPJoN36/p0NRqDoVFs5Lip7EQJq+a2BPFuT+NEbWHGVGbqvBu9+BCoWwwEkMiYe2xEJp2qLRUcdJkI5j6AsxbGFLMoQZHoF+V/Q9UVcRQgPxnDrfQTk1Sss41i796uief5urPJga0yayufoSkBnqJwvmTmtPXGd27p+EbXL57QkwaioDzELMq/noMV50kUb1Lh/N/s4piUI0t2lgNsgCPEXiaYWJShpGGKSwQEGEoxPlNmt28JxRimiSyD+ICiqhUkEzEpAoERFxDWA3ERdZ9dKE4rgB+RAm8nAyP4a6q4PvIN93/HdpNfyjfBCXE+B+pqtRY9t3LBCSCYydV3jEAGSkIpaXMILdAa9dXVCNDJFolBX4yeOETor7b8QelldoSLj7n1ZGb5gBdLgNB1348vRdYGT8pG04WNSYIIoHPPpxQmYPTTNFXEsU+RlPPoCgfM5er5khAWCWED1sh3zc7OMcoG4ALTYoqx76Xc9Rx7rXq5shQRliVMML5+IbxYRTMK1kCct0p+/Rm/99YeEpcE+N+wq+a2BPFumQ3HfHTjUNvLjIzU0nRF8twDIYmJyDi8lnNf+SGgxUoNle8jddbC5FYlEBCUUZS9ldVFR0RLyknDPiDy9ALJg4AH7iuMb39/WsRqE0+yK8eIs4jRG7Kg4rEH/WFCFE65PPxTHs8A/9ajc9/UaBtkGdPFU3l9LjZdxFnZrw/Uc4dxB60ckPOlHQdI7ERxELF+yxCB7J5tC9+GZ9wxd0rRaB7XmJ0mmhKAV8QUkMER/KWCRAXVAQvP8YOfgBW6Ary5lnLO8+aL3vZMw5lSlr1xvIxVaZE+Iu/egCN/EQLlDKTxy/0ajEFGTfPQ4GGdGeFaVnHEK2Qrx75lr1p4iXQ6GylDMokFQoTaXi9hRB9ApOv+N4SgLL74pfKT36zomEWqiU3bsFPP5xBWNBTUURUF1m+RARFRCgfM5mtEF3HSbUDDZhaqmhrKwz8X3ULnI5r34mDN1RvCKcq9IjA/F7EIZHmKBardVSL0MaGtZP5uNMqE2VRZlTez4LBwrZgsAMFtHQ4XXgTmFIbqCI6E0NT9GwgpIBoIuAtGhnKxnSGcc+5NknpUUduz/XK5ADGEIZ3zltQ/pV1JPxnDrfQTkVYNs4CAWHuLiehnDENJQjLV8vxvF4jRG7KgblQ9JHA8Y365GAiyas6AB9dyFOpQvSgneb4QFV9ELC2sEEiwSwlAZYeIV5+NMM45Wit10AF+tLF+z9TUnAhYelPTIb8JI0kyCvkX8BSDHkJQ6rTEBBHBQUFGQ2HB52sOXFNu2MMF6sk/Jb2+C6tP0rL19gzXJr4b3quFLUHKdzzuNPOpc10ojLBxTg1rCJDWya4EOYQtnmWeUW4oeSQqo8mQfVjq4ZZTmp/WAe5Qw6Bf797IoP5RYav+QjMYyGerxXM84nkl7LJ1OSIIRFMZ5jLjNBGQ/CTWZ2IF2YQWaiqYVgaoMcWADF2XNhb3yrugom9XzU15NtpKK6CgoCc/TDboBeA/pCDvpL70IvxhQI04JdUJUlqJ/edH9BFsBL9TbrQJrrdhMKQtOC1W7GAjVIdxSGoRXV2E0xf5QYlLTNqH6o4K0RVJt4agp6/UVrqX6KMRVEZ5==",
    "solution": "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",
    "max-score": 4
  },
  null
]