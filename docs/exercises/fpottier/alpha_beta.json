[
  {
    "learnocaml_version": "2",
    "kind": "exercise",
    "title": "Alpha-Beta Search",
    "stars": 3
  },
  {
    "id": "alpha_beta",
    "prelude": "(* The type of on-demand sequences. (As of OCaml 4.07, this type exists\n   in the standard library.) *)\n\nmodule Seq = struct\n\n  type 'a t = unit -> 'a node\n\n  and +'a node =\n  | Nil\n  | Cons of 'a * 'a t\n\n  let rec map (f : 'a -> 'b) (xs : 'a t) : 'b t =\n    fun () ->\n      match xs() with\n      | Nil ->\n          Nil\n      | Cons (x, xs) ->\n          Cons (f x, map f xs)\n\n  let rec filter (p : 'a -> bool) (xs : 'a t) : 'a t =\n    fun () ->\n      match xs() with\n      | Nil ->\n          Nil\n      | Cons (x, xs) ->\n          if p x then\n            Cons (x, filter p xs)\n          else\n            filter p xs ()\n\n  let rec of_list (xs : 'a list) : 'a t =\n    fun () ->\n      match xs with\n      | [] ->\n          Nil\n      | x :: xs ->\n          Cons (x, of_list xs)\n\n  let rec to_list (xs : 'a t) : 'a list =\n    match xs() with\n    | Nil ->\n        []\n    | Cons (x, xs) ->\n        x :: to_list xs\n\nend\n\n(* -------------------------------------------------------------------------- *)\n\n(* A value is an integer value that reflects the current player view (or\n   evaluation) of the current game configuration. In a zero-sum game, the\n   opponent's view is the opposite of the current player's view, and the\n   value 0 means that both players are even; in particular, in a situation\n   where no more moves can be played, the value 0 represents a draw. *)\n\ntype value =\n  int\n\n(* All of the values that we consider lie in the range [bottom] to [top],\n   inclusive. Note that [bottom] is the opposite of [top]. *)\n\nlet bottom, top =\n  -max_int, max_int\n\n(* We assume that, in every game configuration, a finite number of moves\n   are permitted, and that each of these moves can be identified with an\n   integer code. (A more realistic implementation would be parametric in\n   the type [move].) *)\n\ntype move =\n  int\n\n(* A game tree is either a leaf or not a leaf. A leaf [TLeaf v] means that the\n   game is over and that its value (in the eyes of the current player) is [v].\n   A nonleaf [TNonLeaf mts] means that the game is not over. In that case, at\n   least one move is permitted. The sequence [mts] is then a nonempty sequence\n   of pairs of a permitted move [m] and the subtree that corresponds to this\n   move. This sequence covers all of the permitted moves. *)\n\ntype tree =\n  | TLeaf of value\n  | TNonLeaf of offspring\n\nand offspring =\n  (move * tree) Seq.t\n\n(* -------------------------------------------------------------------------- *)\n\n(* [index] turns a list of things into a list of numbered things. *)\n\nlet rec index i (xs : 'a list) : (int * 'a) list =\n  match xs with\n  | [] ->\n      []\n  | x :: xs ->\n      (i, x) :: index (i+1) xs\n\nlet index xs =\n  index 0 xs\n\n(* The following functions offer facilities for building gamae trees. They may\n   appear in the messages produced by the automated grading system. *)\n\nlet leaf v =\n  TLeaf v\n\nlet nonleaf (ts : tree list) : tree =\n  TNonLeaf (Seq.of_list (index ts))\n    (* [index] is used to generate arbitrary distinct move numbers *)\n\n(* -------------------------------------------------------------------------- *)\n\n(* A notion of sense is used in the reference evaluator, that is, the first\n   function that we write in order to compute the value of a game tree. *)\n\ntype sense =\n  | Even\n  | Odd\n\nlet opposite sense : sense =\n  match sense with Even -> Odd | Odd -> Even\n\nlet interpret sense (v : value) : value =\n  match sense with Even -> v | Odd -> -v\n\nlet join sense : value -> value -> value =\n  match sense with Even -> max | Odd -> min\n\nlet unit sense : value =\n  interpret sense bottom\n\n(* -------------------------------------------------------------------------- *)\n\n(* The following notion of equivalence up to an [alpha, beta] window can be\n   used to specify the expected behavior of the Alpha-Beta algorithm. *)\n\nlet equivalent alpha beta v1 v2 =\n  v1 <= alpha && v2 <= alpha ||\n  v1 = v2 ||\n  beta <= v1 && beta <= v2\n",
    "template": "open Seq\n\n(* -------------------------------------------------------------------------- *)\n\n(* The size of a tree. *)\n\nlet rec size (t : tree) : int =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nand size_offspring (offspring : offspring) : int =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* -------------------------------------------------------------------------- *)\n\n(* The height of a tree. *)\n\nlet rec height (t : tree) : int =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nand height_offspring (offspring : offspring) : int =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* -------------------------------------------------------------------------- *)\n\n(* Evaluating a tree, with a sense parameter: Minimax. *)\n\nlet rec eval (sense : sense) (t : tree) : value =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nand eval_offspring (sense : sense) (offspring : offspring) : value =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* -------------------------------------------------------------------------- *)\n\n(* Evaluating a tree, without a sense parameter: Negamax. *)\n\nlet rec nval (t : tree) : value =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nand nval_offspring (offspring : offspring) =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* -------------------------------------------------------------------------- *)\n\n(* Evaluating a tree, in Negamax style, and looping over children in\n   a tail-recursive manner. *)\n\nlet rec ntval (t : tree) : value =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nand ntval_offspring (running_max : value) (offspring : offspring) : value =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* -------------------------------------------------------------------------- *)\n\n(* Evaluating a tree, using the Alpha-Beta algorithm. *)\n\nlet rec bval (alpha : value) (beta : value) (t : tree) : value =\n  assert (alpha < beta);\n  (* TO DO: Define this function. *)\n  raise TODO\n\nand bval_offspring (alpha : value) (beta : value) (offspring : offspring) : value =\n  assert (alpha < beta);\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* -------------------------------------------------------------------------- *)\n\n(* In a game tree where every leaf carries the value -1 (loss), 0 (draw),\n   or +1 (win), determining whether the first player is assured to win. *)\n\nlet assured_win (t : tree) : bool =\n  (* TO DO: Define this function. *)\n  raise TODO\n\n(* -------------------------------------------------------------------------- *)\n\n(* Evaluating a tree using Alpha-Beta and returning the best move. *)\n\nlet rec bmove_offspring alpha beta (candidate : move option) offspring : move option =\n  assert (alpha < beta);\n  (* TO DO: Define this function. *)\n  raise TODO\n\nlet bmove alpha beta t : move option =\n  assert (alpha < beta);\n  (* TO DO: Define this function. *)\n  raise TODO\n",
    "descr": [
      [
        "",
        "<h1 id=\"Evaluating-a-Game-Tree-Minimax-Negamax-and-Alpha-Beta\">Evaluating a Game Tree: Minimax, Negamax, and Alpha-Beta</h1>\n\n<p>Consider a game of <a href='https://en.wikipedia.org/wiki/Tic-tac-toe'>Tic-Tac-Toe</a>,\nwhere the first player is named X and his opponent is named O.\nHere are a few questions that one might ask about this game,\nand their answers:</p>\n<p>Is X assured to win?</p>\n<ul><li><em>No.</em>\n If both players play perfectly, the game must end in a draw.</li></ul>\n\n<p>Can X make a mistake on his first move?</p>\n<ul><li><em>No.</em>\n If X plays perfectly,\n no opening move by X can lead to a victory for O.</li></ul>\n\n<p>Assuming X plays his first move in a corner,\ncan O make a mistake on his first move?</p>\n<ul><li><em>Yes.</em>\n O must play his first move in the center,\n otherwise, assuming X plays perfectly,\n O will lose.</li></ul>\n\n<p>These questions, as well as many similar questions about Tic-Tac-Toe (and\nabout other two-player games where both players have full information about\nthe current state of the game) can be answered by an algorithm that\n<strong>evaluates</strong> the <strong>game tree</strong>.</p>\n<h2 id=\"Game-Trees\">Game Trees</h2>\n\n<p>A <strong>game tree</strong> is a tree where every node represents a state of the game and\nevery edge represents a move.</p>\n<p>We assume that the game states (and therefore the tree nodes) can be separated\nin two disjoint groups:</p>\n<ul><li><p>The <strong>terminal states</strong> are those where the game is over.\n In a terminal state, no move is permitted.</p>\n</li><li><p>The <strong>nonterminal states</strong> are those where the game is not over.\n In a nonterminal state, at least one move is permitted.</p>\n</li></ul>\n\n<p>The root of the tree represents the initial state of the game. Out of a node\nthat represents a game state <em>s</em>, for every move <em>m</em> that is permitted in state\n<em>s</em>, there is an edge labeled <em>m</em> to a tree node that represents the game\nstate <em>s&#39;</em> obtained by playing move <em>m</em> in state <em>s</em>.</p>\n<p>We assume that <em>the two players take turns</em> in a strictly alternating manner,\nthat is, each player plays one move in turn. Thus, it is always clear which\nplayer is up; this information does not need to be explicitly represented in\nthe tree.</p>\n<p>In this exercise, we adopt an explicit representation of game trees as an\nOCaml algebraic data type. This allows us to split the problem of evaluating a\ngame state as follows:</p>\n<ul><li><p>The person who is responsible for <strong>building a game tree</strong>\n exploits purely game-specific knowledge,\n such as the encoding of game states in memory,\n the rules of the game, and so on.\n No knowledge of the (possibly complex) algorithms\n that are used to evaluate a tree is required.</p>\n</li><li><p>The person who is responsible for <strong>evaluating a game tree</strong>\n does so purely by exploring and reasoning about the tree.\n No knowledge of the underlying game is required.</p>\n</li></ul>\n\n<p>The definition of game trees in OCaml is as follows:</p>\n<pre><code>type tree =\n  | TLeaf of value\n  | TNonLeaf of offspring\n\nand offspring =\n  (move * tree) Seq.t</code></pre>\n\n<p>A tree node is either a <strong>leaf</strong> node, which represents a terminal state,\nor a <strong>nonleaf</strong> node, which represents a nonterminal state.</p>\n<p>A leaf node carries an integer <strong>value</strong>,\nwhich by convention represents the value of this game state\n<em>in the eyes of the player who is currently up</em>.\nThus, for instance, the value +1 might represent a victory\nfor the current player, while the value 0 might represent a draw,\nand the value -1 might represent a defeat for the current player.</p>\n<p>Instead of just -1, 0, and +1, it is permitted to use arbitrary\ninteger values comprised between <code>bottom</code> and <code>top</code> (inclusive).\nThe choice of what value to use at a leaf node is up to whomever\nbuilds a game tree.</p>\n<p>The type <code>value</code> is defined as a synonym for <code>int</code>.\nThe values <code>bottom</code> and <code>top</code> are defined so that\n<code>-bottom</code> is <code>top</code> and <code>-top</code> is <code>bottom</code>:</p>\n<pre><code>type value =\n  int\n\nlet bottom, top =\n  -max_int, max_int</code></pre>\n\n<p>A nonleaf node carries its <strong>offspring</strong>, that is, a nonempty sequence of\npairs of a permitted move and a subtree. This sequence enumerates all of\nthe permitted moves. Each move <em>m</em> in this sequence is accompanied with a\nsubtree whose root node represents the game state that this move leads to.</p>\n<p>We assume that each move is somehow encoded as an integer. The details of\nthis encoding are up to whomever builds a game tree. (The permitted moves\nneed <em>not</em> be encoded as consecutive integers.)</p>\n<pre><code>type move =\n  int</code></pre>\n\n<p>Because an offspring is represented as an OCaml <em>sequence</em>, as opposed to an\nOCaml <em>list</em>, a game tree does not have to reside entirely in memory at once.\n(The definition of OCaml sequences is recalled below.)\nThe parts of the tree that an evaluation algorithm needs to examine are built\non demand, and can be reclaimed by the garbage collector when they are no\nlonger needed. Thus, at a given moment, only one branch, namely the branch\nthat leads from the root of the tree down to the tree node under examination,\nactually needs to reside in memory.</p>\n<p>In this relatively simple-minded approach, there is <em>no sharing</em> of subtrees.\nIf two moves lead to the same game state, then the game tree contains two\nidentical subtrees. In a purely functional setting, there is, unfortunately, no way of recognizing that these\nsubtrees are identical and (thereby) to avoid duplicated work. It is possible\nto do so, using a hash table whose keys are game states, but this is not done\nin this exercise.</p>\n<h2 id=\"On-Demand-Sequences\">On-Demand Sequences</h2>\n\n<p>The type of <strong>on-demand sequences</strong> is defined in a module named <code>Seq</code>.\nBeginning with version 4.07,\nthis module is part of OCaml&#39;s standard library.</p>\n<pre><code>module Seq : sig\n\n  type &#39;a t = unit -&gt; &#39;a node\n\n  and +&#39;a node =\n  | Nil\n  | Cons of &#39;a * &#39;a t\n\nend</code></pre>\n\n<p>This data type is closely related to the algebraic data type of lists.\nIndeed, if instead of <code>unit -&gt; &#39;a node</code> one had written just <code>&#39;a node</code>,\nthen this data type would have been isomorphic to the type of lists.</p>\n<p>The presence of <code>unit -&gt; ...</code> indicates that a sequence is in fact a function.\nCalling this function, by applying it to the value <code>()</code>, amounts to requesting\nthe head of the sequence. This head can be either <code>Nil</code>, which means that the\nsequence is empty, or <code>Cons (x, xs)</code>, which means that the first element of\nthe sequence is <code>x</code> and the remaining elements form another sequence <code>xs</code>. It\nis worth noting that <code>xs</code> is itself a function, so the elements of the\nsequence <code>xs</code> need not be explicitly computed until <code>xs</code> is applied.</p>\n<h2 id=\"Warmup-Size-and-Height\">Warmup: Size and Height</h2>\n\n<p>As a warmup, let us implement two functions that compute the size and the\nheight of a game tree.</p>\n<p>The <strong>size</strong> of a game tree is the number of its nodes (including both leaf\nand nonleaf nodes).</p>\n<p>The <strong>height</strong> of a game tree is the maximum length of a branch. In other\nwords, it is the maximum number of moves that can be played consecutively,\nbeginning in the initial game state.</p>\n<p><strong>Question 1.</strong> Define the function <code>size</code>,\nwhose type is <code>tree -&gt; int</code>.</p>\n<p><strong>Question 2.</strong> Define the function <code>height</code>,\nwhose type is <code>tree -&gt; int</code>.</p>\n<h2 id=\"Evaluating-a-Game-Tree-the-Minimax-Algorithm\">Evaluating a Game Tree: the Minimax Algorithm</h2>\n\n<p>Suppose that we are given a game tree. We wish to <strong>evaluate</strong> it, that is, to\ncompute the best possible outcome of the game for the player who is initially\nup (the one who plays the first move), under the assumption that his opponent\nplays perfectly. We refer to this player as <code>Even</code>, and refer to his opponent\nas <code>Odd</code>. This is reflected in the following type definition:</p>\n<pre><code>type sense =\n  | Even\n  | Odd</code></pre>\n\n<p>The following auxiliary functions will be useful below. In particular,\n<code>interpret sense</code> transforms a value that is relative to the player <code>sense</code>\nto a value that is relative to the player <code>Even</code>. The value <code>unit sense</code> is\nthe neutral element of the binary operation <code>join sense</code>.</p>\n<pre><code>let opposite sense : sense =\n  match sense with Even -&gt; Odd | Odd -&gt; Even\n\nlet interpret sense (v : value) : value =\n  match sense with Even -&gt; v | Odd -&gt; -v\n\nlet join sense : value -&gt; value -&gt; value =\n  match sense with Even -&gt; max | Odd -&gt; min\n\nlet unit sense : value =\n  interpret sense bottom</code></pre>\n\n<p>What is the value in the eyes of the player <code>Even</code> of a game tree <code>t</code>,\nunder the assumption that, at the root of the tree, the player <code>Even</code> is up?</p>\n<ul><li><p>If <code>t</code> is a leaf <code>TLeaf v</code>,\n then the player <code>Even</code> has no choice (the game is over),\n and the value of the tree is just <code>v</code>.</p>\n</li><li><p>If <code>t</code> is an internal node <code>TNonLeaf offspring</code>,\n where <code>offspring</code> is a sequence of pairs of a move and a subtree,\n then the player <code>Even</code> has a choice between these moves\n and can pick an optimal one,\n so the value is the maximum of the values in the eyes of the player <code>Even</code>\n of these subtrees <em>where the player</em> <code>Odd</code> <em>is now up</em>.</p>\n</li></ul>\n\n<p>This leads us to ask a dual question.\nWhat is the value in the eyes of the player <code>Even</code> of a game tree <code>t</code>,\nunder the assumption that, at the root of the tree, the player <code>Odd</code> is up?</p>\n<ul><li>We let you answer this question by yourself!</li></ul>\n\n<p><strong>Question 3.</strong> Define a function <code>eval</code> of type <code>sense -&gt; tree -&gt; value</code>\nsuch that <code>eval sense t</code> computes the value in the eyes of the player <code>Even</code>\nof the game tree <code>t</code>, under the assumption that, at the root of the tree, the\nplayer <code>sense</code> is up.</p>\n<p><em>Hint.</em> In order to avoid code duplication between the case where <code>sense</code> is\n <code>Even</code> and the case where <code>sense</code> is <code>Odd</code>, make use of the auxiliary\n functions <code>opposite</code>, <code>interpret</code>, <code>join</code>, and <code>unit</code>.</p>\n<p><em>Note.</em> Because this code alternates between computing a maximum (at even\nlevels in the tree) and a minimum (at odd levels in the tree), it is known as\nthe <a href='https://en.wikipedia.org/wiki/Minimax'>Minimax</a> algorithm. The parameter\n<code>sense</code> is so named because this is a typical name for a parameter that\nalternates between two values.</p>\n<p><em>Note.</em> If the value of a game tree <code>t</code> in the eyes of one player is <code>v</code>, then\nits value in the eyes of the other player is <code>-v</code>. Thus, the function <code>eval</code>\nmust satisfy the following law: <code>eval (opposite sense) t = -(eval sense t)</code>.</p>\n<h2 id=\"Evaluating-a-Game-Tree-the-Minimax-Algorithm-in-Negamax-Style\">Evaluating a Game Tree: the Minimax Algorithm in Negamax Style</h2>\n\n<p>Although it seems reasonable to parameterize the Minimax algorithm with a\n<code>sense</code> parameter, as done above, there is a different formulation of the\nalgorithm, known as <a href='https://en.wikipedia.org/wiki/Negamax'>Negamax</a>, where\nthis parameter is unnecessary.</p>\n<p>This formulation relies on the remark that was made above:\n<code>eval (opposite sense) t</code> is equal to <code>-(eval sense t)</code>. Thus, the function\n<code>eval sense</code> can be formulated in such a way that every recursive call is of\nthe form <code>eval sense</code>, and no recursive call is of the form\n<code>eval (opposite sense)</code>.\nTherefore, the <code>sense</code> parameter is actually unnecessary! We can write a new\nevaluation function, <code>nval</code>, which does not take such a parameter.</p>\n<p><strong>Question 4.</strong> Define a function <code>nval</code> of type <code>tree -&gt; value</code> such that\n<code>nval t</code> computes the value of the game tree <code>t</code> in the eyes of the player who\nis up at the root of the tree.</p>\n<p><em>Note.</em> The connection between <code>nval</code> and <code>eval</code> is described by the following\nlaw: <code>interpret sense (nval t) = eval sense t</code>. By replacing <code>sense</code> with\n<code>Even</code> in this law, we find, in particular, <code>nval t = eval Even t</code>.</p>\n<h2 id=\"Evaluating-a-Game-Tree-the-Minimax-Algorithm-in-Negamax-Tail-Recursive-Style\">Evaluating a Game Tree: the Minimax Algorithm in Negamax Tail-Recursive Style</h2>\n\n<p>In your answer to the previous question, you have likely defined the function\n<code>nval_offspring</code> in a recursive manner, using an expression of the form <code>max\n(...) (nval_offspring ...))</code>. Such an expression is certainly easy to read.\nHowever, this style exhibits a few weaknesses:</p>\n<ul><li><p>The maximum of the two values is computed <em>after</em> the recursive call.\n In other words, this is not a tail call.</p>\n</li><li><p>The OCaml programming language does not specify in what order the actual\n arguments are evaluated in a function call. Thus, it is not clear which of\n the two arguments of <code>max</code> is evaluated first. As a result, it is not clear\n in what order the subtrees are evaluated: in the order in which they appear\n in the sequence, or in the reverse order?</p>\n</li></ul>\n\n<p>To address these shortcomings, it is preferable to organize the code in a\nslightly different manner, where it is clear that the subtrees are evaluated\nin the order in which they appear in the sequence, and where the recursive\ncall is a\n<a href='https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/data/tail_recursion.html'>tail call</a>.\nThis allows the OCaml compiler to produce code for a loop that iterates over\nthe sequence of subtrees.</p>\n<p><strong>Question 5.</strong> Define a function <code>ntval</code> of type <code>tree -&gt; value</code> such that\n<code>ntval t</code> computes the value of the game tree <code>t</code> in the eyes of the player\nwho is up at the root of the tree.</p>\n<p><em>Hint.</em> The auxiliary function <code>ntval_offspring</code> should now take two\nparameters, namely <code>running_max</code>, the maximum value of the subtrees that have\nalready been examined, and <code>offspring</code>, the sequence of the subtrees that\nremain to be examined.</p>\n<p><em>Hint.</em> The recursive call of <code>ntval_offspring</code> to itself should be a tail\ncall.</p>\n<p><em>Note.</em> The connection between <code>ntval</code> and <code>nval</code> is simple: <code>ntval t</code> must be\nequal to <code>nval t</code>.</p>\n<h2 id=\"Evaluating-a-Game-Tree-the-Alpha-Beta-Algorithm-in-Negamax-Style\">Evaluating a Game Tree: the Alpha-Beta Algorithm in Negamax Style</h2>\n\n<p>Imagine that you are playing a game of chess. You suddenly discover that, if\nyour tower leaves the first row, then your opponent can move his own tower\ninto this row and checkmate. Do you ask yourself <em>what other moves</em> your\nopponent might play instead? No: the fact that your opponent has a winning\nmove is sufficient grounds to stop examining this situation and recognize that\nmoving your tower away is a bad move.</p>\n<p>This suggests that the value of a game tree can in some cases be determined\nwithout examining the entire tree. Some subtrees can be <em>pruned</em>, that is,\nnever examined.</p>\n<p>The\n<a href='https://en.wikipedia.org/wiki/Negamax#Negamax_with_alpha_beta_pruning'>Alpha-Beta</a>\nalgorithm improves on the Minimax algorithm by abandoning a sequence of\nsubtrees as soon as it is clear that their values are irrelevant. This yields\na dramatic performance improvement: it is an essential optimization.</p>\n<p>As its name suggests, the Alpha-Beta algorithm is parameterized by two values,\n<code>alpha</code> and <code>beta</code>, which must satisfy the strict inequality <code>alpha &lt; beta</code>.\nThe algorithm is expected to evaluate a game tree <code>t</code> and is allowed to return\nan <em>approximation</em> of the exact value <code>v</code> of <code>t</code>, as follows:</p>\n<ul><li><p>If the value <code>v</code> lies strictly within the open interval <code>(alpha, beta)</code>,\n then the algorithm must return exactly <code>v</code>.</p>\n</li><li><p>If <code>v</code> lies within the closed interval <code>[bottom, alpha]</code>,\n then the algorithm may return any value in this interval.\n The idea is, if the value of the tree <code>t</code> is <code>alpha</code> or below <code>alpha</code>,\n then it is a <em>bad</em> tree in the eyes of the current player,\n and there is no need to find out exactly how bad it is:\n we will not play it.</p>\n</li><li><p>If <code>v</code> lies within the closed interval <code>[beta, top]</code>,\n then the algorithm may return any value in this interval.\n The idea is, if the value of the tree <code>t</code> is <code>beta</code> or above <code>beta</code>,\n then it is a <em>good</em> tree in the eyes of the current player,\n and there is no need to find out exactly how good it is:\n our opponent will not give us the opportunity of playing it.</p>\n</li></ul>\n\n<p>In other words, the exact value of a game tree and the approximate value\ncomputed by the Alpha-Beta algorithm must be <code>(alpha, beta)</code><em>-equivalent</em> in the\nfollowing sense:</p>\n<pre><code>let equivalent alpha beta v1 v2 =\n  v1 &lt;= alpha &amp;&amp; v2 &lt;= alpha ||\n  v1 = v2 ||\n  beta &lt;= v1 &amp;&amp; beta &lt;= v2</code></pre>\n\n<p><strong>Question 6.</strong> Define a function <code>bval</code> of type <code>value -&gt; value -&gt; tree -&gt;\nvalue</code> such that <code>bval t</code> computes the value of the game tree <code>t</code> in the eyes\nof the player who is up at the root of the tree, up to <code>(alpha,\nbeta)</code>-equivalence.</p>\n<p><em>Note.</em> The connection between <code>ntval</code> and <code>bval</code> is described by the\nfollowing law: <code>equivalent alpha beta (bval alpha beta t) (ntval t)</code>.\nIn particular, by instantiating <code>alpha</code> with <code>bottom</code> and <code>beta</code> with\n<code>top</code>, we find the following law as a special case:\n<code>bval bottom top t = ntval t</code>.\nIn other words, the Alpha-Beta algorithm computes the same result\nas the Minimax algorithm\nwhen the <code>(alpha, beta)</code> window covers the entire range of values.</p>\n<p><em>Hint.</em> The functions <code>bval</code> and <code>bval_offspring</code> are very similar to the\nfunctions <code>ntval</code> and <code>ntval_offspring</code> defined earlier.</p>\n<p><em>Hint.</em> The parameter <code>alpha</code> in <code>bval_offspring</code> plays essentially the same\nrole as the parameter <code>running_max</code> in <code>ntval_offspring</code>, and is updated in\nexactly the same way. Indeed, once we have found a subtree whose value is <code>v</code>,\nwe can view every value below <code>v</code> as <em>bad</em>. Because we are not interested in\ndistinguishing between bad values, we can update <code>alpha</code> to be at least <code>v</code>.</p>\n<p><em>Hint.</em> The parameter <code>beta</code> in <code>bval_offspring</code> allows pruning. If we find a\nsubtree whose value is <code>beta</code> or above <code>beta</code>, then this is <em>good</em>, and there\nis no need to examine the rest of the sequence of subtrees. This is known as\na <em>cut</em>.</p>\n<p><em>Hint.</em> We keep working in Negamax style. So, when we make a recursive call to\n<em><code>bval</code>, we must provide values of <code>alpha</code> of <code>beta</code> that make sense *in the\neyes of the opponent.</em></p>\n<h2 id=\"Application-Finding-and-Playing-a-Winning-Strategy\">Application: Finding and Playing a Winning Strategy</h2>\n\n<p>Recall the question that we asked at the very beginning: in a game of\nTic-Tac-Toe, is the first player assured to win? Suppose we are interested in\njust a binary answer, that is, &quot;yes&quot; or &quot;no&quot;. (If the answer is &quot;no&quot;, we are\nnot interested in determining whether the second player is assured to win or\nthe game must end in a draw.) How can this question be efficiently answered\nusing the Alpha-Beta algorithm?</p>\n<p><strong>Question 7.</strong> Define a function <code>assured_win</code> of type <code>tree -&gt; bool</code> such\nthat <code>assured_win t</code> is <code>true</code> if and only if the player who is up at the root\nof the game tree <code>t</code> is assured to win, under the assumption that every leaf\nin the tree <code>t</code> carries the value -1 (loss), 0 (draw), or +1 (win).</p>\n<p>Being able to evaluate a game tree, and being able to tell that we assured to\nwin, is a good thing, but does not directly tell us <em>how</em> to win. Fortunately,\nit is easy to define a variant of <code>bval</code> that returns not only the value of\nthe game tree, but also an optimal move.</p>\n<p>A move is <em>optimal</em> if it achieves an optimal result in the eyes of the player\nwho is up. In other words, it is optimal if it leads to a subtree whose value\n(in the eyes of the current player) is the same as the value of the entire\ntree.</p>\n<p><strong>Question 8.</strong> Define a function <code>bmove</code> of type\n<code>value -&gt; value -&gt; tree -&gt; move option</code>\nsuch that <code>bmove alpha beta t</code>\nreturns <code>None</code> if the game tree <code>t</code> is a leaf\nand\nreturns <code>Some move</code> if the game tree <code>t</code> is of the form <code>TNonLeaf offspring</code>\nand <code>move</code> is the first move in the sequence <code>offspring</code> that achieves the\noptimal value <code>bval alpha beta t</code>.</p>\n<h2 id=\"Comments\">Comments</h2>\n\n<p>We have implemented algorithms that evaluate a game tree by exploring it\nentirely, all the way down to its leaves (except of course where pruning is\npossible). If one wishes to evaluate a game tree only <strong>down to a limited\ndepth</strong> <code>d</code>, this can be done, without modifying the evaluation algorithms\ndeveloped above, by pruning the tree at this depth, that is, by constructing a\nshallower game tree where every node at depth <code>d</code> in the original tree is\nreplaced with a leaf. The value of this leaf is usually determined by a\nheuristic <em>evaluation function</em> which, given a game state, attempts to guess\nthe value of this game state.</p>\n<p>We have defined an explicit algebraic data type of game trees because this\nallows us to abstract the game state away from the evaluation algorithm and to\ntest the evaluation algorithm with artificial game trees, independently of any\nactual game. However, this simple and elegant approach has a cost. First,\nallocating the game tree in memory imposes a penalty in terms of performance.\nSecond, and more seriously, hiding the game state from the evaluation\nalgorithm prevents us from making several crucial improvements to the\nAlpha-Beta algorithm. For this reason, in a real-world implementation, the\nevaluation algorithm would have direct access to game states, and no tree\nwould be explicitly built. The main improvements that could then be made are\nas follows:</p>\n<ul><li><p><strong>Exploiting sharing.</strong> It is common for a game state to be reachable via\n different paths. Therefore, the state space of the game forms a <em>directed\n graph</em>. Representing this graph as a tree is correct, but is extremely\n inefficient, as this tree is typically exponentially larger than the\n underlying graph. In other words, when the state space of the game is\n represented as a tree, a single game state can appear in many places in the\n tree, and therefore can be evaluated many times. This leads to repeated\n work. In order to avoid this phenomenon, one must attempt to recognize that\n a game state has been reached and evaluated already. This is typically done\n by using a hash table, which in this case is usually known as a\n <em>transposition table</em>. Extending the Minimax algorithm with a transposition\n table is easy. Extending Alpha-Beta with a transposition table is slightly\n more difficult, as the values of <code>alpha</code> and <code>beta</code> are not necessarily the\n same when a game state is first visited and when it is visited again, but,\n with some care, this can be done. This yields an important gain in time, at\n a large cost in space.</p>\n</li><li><p><strong>Exploiting symmetries.</strong> Some games exhibit symmetries. For instance, in\n Connect 4, taking the mirror image of the board (with respect to a vertical\n axis that goes through the center of the board) changes a game state to\n another game state whose value is the same. This remark allows dividing by 2\n the number of game states that must be evaluated. Similarly, in Tic-Tac-Toe,\n rotating the board by 90 degrees changes a game state to an equivalent game\n state. This remark allows dividing by 4 the number of game states that must\n be evaluated.</p>\n</li><li><p><strong>Exploiting move ordering.</strong> In a given game state, several moves are\n usually permitted. In what order should these moves be explored? For the\n Minimax algorithm, this makes no difference. For the Alpha-Beta algorithm,\n however, it is desirable to explore better moves first, because this leads\n to more pruning, therefore better performance. Naturally, it is not known a\n priori which moves are best. One approach is to use a heuristic function,\n based on game-specific knowledge, to determine which moves seem most\n promising. Another approach is to exploit <strong>iterative deepening</strong>, that is,\n to run the Alpha-Beta algorithm successively down to some depth <code>d</code>, then\n down to depth <code>d+1</code>, then down to depth <code>d+2</code>, and so on. The approximate\n values obtained during one run are used during the next run to determine\n which moves look most promising. Because the cost of the last run alone\n usually dwarfs the combined cost of all previous runs, the cost of iterative\n deepening is not a problem; this technique is usually beneficial.</p>\n</li></ul>"
      ]
    ],
    "prepare": "FUrKIQ+x+rz+bXYvYihA",
    "test": "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",
    "solution": "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",
    "max-score": 14,
    "depend": null,
    "dependencies": []
  },
  null
]