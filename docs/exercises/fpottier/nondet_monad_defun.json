[
  {
    "learnocaml_version": "2",
    "kind": "exercise",
    "title": "Implementing Nondeterminism as an Abstract Machine",
    "stars": 3
  },
  {
    "id": "nondet_monad_defun",
    "prelude": "(* The module [Seq] is standard as of OCaml 4.07. *)\n\nmodule Seq = struct\n\n  type 'a t = unit -> 'a node\n\n  and +'a node =\n  | Nil\n  | Cons of 'a * 'a t\n\n  let nil =\n    fun () -> Nil\n\n  let cons x xs =\n    fun () -> Cons (x, xs)\n\n  let singleton x =\n    cons x nil\n\n  let rec map (f : 'a -> 'b) (xs : 'a t) : 'b t =\n    fun () ->\n      match xs() with\n      | Nil ->\n          Nil\n      | Cons (x, xs) ->\n          Cons (f x, map f xs)\n\n  let rec concat (xs : 'a t) (ys : 'a t) : 'a t =\n    fun () ->\n      match xs() with\n      | Nil ->\n          ys()\n      | Cons (x, xs) ->\n          Cons (x, concat xs ys)\n\n  let rec flatten (xss : 'a t t) : 'a t =\n    fun () ->\n      match xss() with\n      | Nil ->\n          Nil\n      | Cons (xs, xss) ->\n          concat xs (flatten xss) ()\n\n  let rec take n (xs : 'a t) : 'a t =\n    if n = 0 then\n      nil\n    else\n      fun () ->\n        match xs() with\n        | Nil ->\n            Nil\n        | Cons (x, xs) ->\n            Cons (x, take (n-1) xs)\n\n  let head (xs : 'a t) : 'a option =\n    match xs() with\n    | Nil ->\n        None\n    | Cons (x, _) ->\n        Some x\n\n  let rec of_list (xs : 'a list) : 'a t =\n    fun () ->\n      match xs with\n      | [] ->\n          Nil\n      | x :: xs ->\n          Cons (x, of_list xs)\n\n  (* A word of warning: [to_list] does not terminate if it is applied\n     to an infinite sequence. Furthermore, this version of [to_list]\n     is not tail-recursive and could exhaust the stack space if it was\n     applied to a long sequence. *)\n\n  let rec to_list (xs : 'a t) : 'a list =\n    match xs() with\n    | Nil ->\n        []\n    | Cons (x, xs) ->\n        x :: to_list xs\n\nend\n\n(* A nondeterministic computation is a data structure, described by the\n   following generalized algebraic data type. *)\n\n(* A nondeterministic computation can also be interpreted as a process\n   that produces a sequence of results. This interpretation is performed\n   by the function [compute]. *)\n\ntype 'a m =\n| MDelay:               (unit -> 'a m) -> 'a m\n| MReturn:                          'a -> 'a m\n| MBind:           'a m * ('a -> 'b m) -> 'b m\n| MFail:                                  'a m\n| MChoose:                 'a m * 'a m -> 'a m\n| MReflect: ('a * 'a m) option failure -> 'a m\n\n(* A failure continuation is a data structure, described by the following\n   generalized algebraic data type. *)\n\n(* A failure continuation can also be interpreted as a function that takes\n   no argument and returns a final answer. This interpretation is performed\n   by the function [apply_failure]. *)\n\n(* An [FChoose] entry is known in the logic programming literature as a\n   choice point. Each [FChoose] entry contains a pointer [f] to another\n   failure continuation, so a failure continuation can be viewed as a\n   stack of choice points, represented in memory as a linked list. One\n   of [FSols] and [FSplit] serves to indicate the bottom of the stack. *)\n\nand 'answer failure =\n| FChoose:\n    (* m2: *) 'a m *\n    (* s : *) ('a, 'answer) success *\n    (* f : *) 'answer failure ->\n              'answer failure\n| FSols:\n    _ Seq.node failure\n| FSplit:\n    _ option failure\n\n(* A success continuation is a data structure, described by the following\n   generalized algebraic data type. *)\n\n(* A success continuation can also be interpreted as a function that takes\n   one argument (a result) and returns a final answer. This interpretation\n   is performed by the function [apply_success]. *)\n\n(* Each [SBind] entry contains a pointer [s] to another success continuation,\n   so a success continuation can be viewed as a stack, represented in memory\n   as a linked list. One of [SSols] and [SSplit] serves to indicate the bottom\n   of the stack. *)\n\nand ('a, 'answer) success =\n| SBind:\n    (* m2: *) ('a -> 'b m) *\n    (* s : *) ('b, 'answer) success ->\n              ('a, 'answer) success\n| SSols:\n    ('a, 'a Seq.node) success\n| SSplit:\n    ('a, ('a * 'a m) option) success\n\n(* Implementing this constructor function is immediate. *)\n\nlet delay (m : unit -> 'a m) : 'a m =\n  MDelay m\n\n(* The effect of executing the computation [tick m] is to first increment the\n   global counter [work], then execute the computation [m]. *)\n\n(* The grading code uses these operations in order to check that computations\n   are executed on demand, that is, as late as possible. *)\n\nlet work =\n  ref 0\n\nlet reset() =\n  work := 0\n\nlet tick (m : 'a m) : 'a m =\n  delay (fun () ->\n    work := !work + 1;\n    m\n  )\n\nlet snapshot (x : 'a) : 'a * int =\n  (x, !work)\n",
    "template": "(* The following four constructor functions are implemented already. *)\n\nlet return (x : 'a) : 'a m =\n  MReturn x\n\nlet (>>=) (m1 : 'a m) (m2 : 'a -> 'b m) : 'b m =\n  MBind (m1, m2)\n\nlet fail : 'a m =\n  MFail\n\nlet choose (m1 : 'a m) (m2 : 'a m) : 'a m =\n  MChoose (m1, m2)\n\n(* The bulk of the work is to implement an interpreter for each of the\n   data types [_ failure], [(_, _) success], and [_ m]. *)\n\nlet rec apply_failure : type answer . answer failure -> unit -> answer =\n  fun f () ->\n    match f with\n    | FChoose (m2, s, f) ->\n        (* Invoked when the left branch of a choice has failed.\n           [m2] is the right branch of the choice.\n           [s] and [f] are the continuations of the choice. *)\n        raise TODO (* one line *)\n    | FSols ->\n        (* Used at the top level of [sols].\n           Invoked when there is no result. *)\n        raise TODO (* one line *)\n    | FSplit ->\n        (* Used at the top level of [msplit].\n           Invoked when there is no result. *)\n        raise TODO (* one line *)\n\nand apply_success : type a answer .\n  (a, answer) success -> a -> answer failure -> answer\n=\n  fun s x f ->\n    match s with\n    | SBind (m2, s) ->\n        (* Invoked when the left branch of a sequence produces a result [x].\n           [m2] is the right-hand side of the sequence.\n           [s] is the success continuation of the sequence. *)\n        raise TODO (* one line *)\n    | SSols ->\n        (* Used at the top level of [sols].\n           Invoked when the computation produces a result [x]. *)\n        (* Hint: construct a sequence whose head is [x] and whose\n                 tail is [f], converted to the type of a sequence.\n                 There is an easy way of performing this conversion. *)\n        raise TODO (* one line *)\n    | SSplit ->\n        (* Used at the top level of [msplit].\n           Invoked when the computation produces a result [x]. *)\n        (* Hint: construct an optional-pair whose first component is [x]\n                 and whose second component is [f], converted to the type\n                 of a computation. There is an easy way of performing this\n                 conversion.  *)\n        raise TODO (* one line *)\n\nand compute : type a answer .\n  a m -> (a, answer) success -> answer failure -> answer\n=\n  fun m s f ->\n    match m with\n    | MDelay m ->\n        (* Hint: evaluate [m()] and continue. *)\n        raise TODO (* one line *)\n    | MReturn x ->\n        (* Hint: successfully produce the result [x]. *)\n        raise TODO (* one line *)\n    | MBind (m1, m2) ->\n        (* Hint: enter the left-hand side [m1] with an\n                 appropriate success continuation. *)\n        raise TODO (* one line *)\n    | MFail ->\n        (* Hint: fail. *)\n        raise TODO (* one line *)\n    | MChoose (m1, m2) ->\n        (* Hint: enter the left-hand side [m1] with an\n                 appropriate failure continuation. *)\n        raise TODO (* one line *)\n    | MReflect k ->\n        (* We have a failure continuation [k], which was captured earlier and\n           wrapped with [MReflect] so as to disguise it as a computation. We are\n           now asked to execute this computation. Thus, we must call this\n           failure continuation, whose answer type is [('a * 'a m) option].\n           Depending on whether this yields [None] or [Some (x, m)], we must\n           behave either like [fail] or like [choose (return x) m]. *)\n        raise TODO (* five lines *)\n\nlet sols (m : 'a m) : 'a Seq.t =\n  (* TO DO: Define this function. *)\n  raise TODO (* one line *)\n\nlet msplit (m : 'a m) : unit -> ('a * 'a m) option =\n  (* TO DO: Define this function. *)\n  raise TODO (* one line *)\n\nlet at_most_once (m : 'a m) : 'a m =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nlet rec interleave (m1 : 'a m) (m2 : 'a m) : 'a m =\n  (* TO DO: Define this function. *)\n  raise TODO\n\nlet rec (>>-) (m1 : 'a m) (m2 : 'a -> 'b m) : 'b m =\n  (* TO DO: Define this function. *)\n  raise TODO\n",
    "descr": [
      [
        "",
        "<h1 id=\"Implementing-Nondeterminism-as-an-Abstract-Machine\">Implementing Nondeterminism as an Abstract Machine</h1>\n\n<p>In this exercise, we build an implementation of the nondeterminism\nmonad. This monad admits several possible implementations. The one\nthat we choose here can be described as an <em>abstract machine</em> that\ninterprets a piece of <em>code</em> and uses two auxiliary stack-like data\nstructures, namely a <em>success continuation</em>, and a <em>failure continuation</em>.\nEach of these three data structures is described by a generalized\nalgebraic data type.</p>\n<p>This implementation can be viewed as a defunctionalized version\nof the continuation-based implementation studied in\n<a onclick=\"top.location='/exercises/nondet_monad_cont/';\" href=''>another exercise</a>.\nThe underlying algorithm is exactly the same,\nbut whereas the continuation-based implementation represents\ncode and continuations as first-class functions,\nthis implementation represents them as data structures.</p>\n<p>We suggest doing the other exercise first\nand attempting this exercise next.</p>\n<h2 id=\"The-Nondeterminism-Monad\">The Nondeterminism Monad</h2>\n\n<p>When searching for the solution of a problem, one must typically\nexplore multiple choices. If a series of choices lead to a failure\n(a dead end), then one must backtrack and explore another avenue.</p>\n<p>There are a number of ways in which nondeterminism and backtracking\ncan be implemented. Regardless of which implementation mechanism is\nchosen, it is desirable to hide it behind an abstraction barrier and\npresent the end user with <strong>a simple API for constructing an executing\nnondeterministic computations</strong>.</p>\n<p>This API is known as the <strong>nondeterminism monad</strong>. It offers the\nfollowing key elements:</p>\n<ul><li><p>A type <code>&#39;a m</code>, the type of computations that yield results of type\n <code>&#39;a</code>.</p>\n</li><li><p>A number of constructor functions for constructing computations,\n such as <code>fail: &#39;a m</code>, which represents failure, and <code>choose: &#39;a m\n  -&gt; &#39;a m -&gt; &#39;a m</code>, which expresses a nondeterministic choice\n between two computations.</p>\n</li><li><p>A single observation function, <code>sols: &#39;a m -&gt; &#39;a Seq.t</code>, which\n converts a computation to a sequence of results, thereby allowing\n the user to execute this computation and observe its results. The\n name <code>sols</code> stands for <code>solutions</code>.</p>\n</li></ul>\n\n<p>A monad can be thought of as a <strong>mini-programming language</strong> where\ncomputations are first-class citizens: we have a type of\ncomputations, ways of building computations, and a way of executing\ncomputations.</p>\n<p>A computation in the nondeterminism monad can produce zero, one, or\nmore results. Indeed, a computation that fails produces zero\nresults. A computation that succeeds normally produces one result.\nA computation that uses <code>choose</code> can produce more than one result.\nIt is in fact possible to construct computations that produce an\ninfinite number of results!</p>\n<p>Thus, a useful way to think of a computation is as <strong>a sequence of\nresults</strong>, that is, a sequence of results.</p>\n<p>Because of this remark, one might be tempted to define the type <code>&#39;a\nm</code> as a synonym for <code>&#39;a Seq.t</code>, the type of sequences of values of\ntype <code>&#39;a</code>. However, although it is possible to represent a\ncomputation internally as a sequence (and we will do so in this\nexercise), this is not necessarily the best implementation\ntechnique. Thus, we prefer to make the API more flexible by viewing\n<code>&#39;a m</code> as an abstract type and by offering an observation function,\n<code>sols</code>, which converts a computation to a sequence.</p>\n<h2 id=\"The-Nondeterminism-Monad-39-s-API\">The Nondeterminism Monad&#39;s API</h2>\n\n<p>The signature, or API, of the nondeterminism monad is as follows:</p>\n<pre><code>  (* Type. *)\n  type &#39;a m\n\n  (* Constructor functions. *)\n  val return: &#39;a -&gt; &#39;a m\n  val (&gt;&gt;=): &#39;a m -&gt; (&#39;a -&gt; &#39;b m) -&gt; &#39;b m\n  val fail: &#39;a m\n  val choose: &#39;a m -&gt; &#39;a m -&gt; &#39;a m\n  val delay: (unit -&gt; &#39;a m) -&gt; &#39;a m\n  val at_most_once: &#39;a m -&gt; &#39;a m\n  val interleave: &#39;a m -&gt; &#39;a m -&gt; &#39;a m\n  val (&gt;&gt;-): &#39;a m -&gt; (&#39;a -&gt; &#39;b m) -&gt; &#39;b m\n\n  (* Observation function. *)\n  val sols: &#39;a m -&gt; &#39;a Seq.t</code></pre>\n\n<p>As explained above, a value of type <code>&#39;a m</code> is <strong>a description of a\ncomputation</strong>, which, once executed, produces a sequence of results\nof type <code>&#39;a</code>.</p>\n<p>To execute a computation <code>m</code>, one must first convert it to a\nsequence of type <code>&#39;a Seq.t</code>, whose elements can then be demanded,\none by one. (More information on the module <code>Seq</code> is given below.)\nThis conversion is performed by the observation function <code>sols</code>.</p>\n<p>The call <code>sols m</code> typically terminates in constant time; the actual\ncomputation described by <code>m</code> takes place only when the elements of\nthe sequence <code>sols m</code> are demanded, and only insofar as necessary to\nproduce the elements that are demanded. For instance, applying\n<code>Seq.head</code> to the sequence <code>sols m</code> forces the computation to\nproceed up to the point where it is able to produce its first\nresult.</p>\n<p>The constructor functions <code>return</code> and <code>(&gt;&gt;=)</code> exist in all monads.\n(They are also known as <code>return</code> and <code>bind</code>.) <code>return</code> constructs a\ntrivial computation, which does nothing except return a value,\nwhereas <code>(&gt;&gt;=)</code> constructs the sequential composition of two\ncomputations. Together, they allow constructing the sequential\ncomposition of an arbitrary number of computations.</p>\n<ul><li><p>The computation <code>return v</code> succeeds exactly once with the value\n <code>v</code>. In other words, the sequence of values that it produces is\n the singleton sequence composed of just <code>v</code>.</p>\n</li><li><p>The computation <code>m1 &gt;&gt;= m2</code> is the sequential composition of the\n computations <code>m1</code> and <code>m2</code>. This composition operator is\n asymmetric: whereas its first argument <code>m1</code> is a computation of\n type <code>&#39;a m</code>, its second argument <code>m2</code> is a function of type <code>a -&gt;\n  &#39;b m</code>. Every value <code>x</code> produced by <code>m1</code> is passed to <code>m2</code>,\n yielding a computation <code>m2 x</code>. The sequence of values produced by\n <code>m1 &gt;&gt;= m2</code> is the concatenation of the sequences of values\n produced by the computations <code>m2 x</code>, where <code>x</code> ranges over the\n values produced by <code>m1</code>.</p>\n</li></ul>\n\n<p>The constructor functions <code>fail</code> and <code>choose</code> are specific of the\nnondeterminism monad. <code>fail</code> can be thought of as a 0-ary\ndisjunction, whereas <code>choose</code> is a binary disjunction. Together,\nthey allow constructing the disjunction of an arbitrary number of\ncomputations.</p>\n<ul><li><p>The computation <code>fail</code> returns no result. In other words, it\n produces an empty sequence of values.</p>\n</li><li><p>The sequence of values produced by <code>choose m1 m2</code> is the\n concatenation of the sequences of values produced by <code>m1</code>\n and by <code>m2</code>.</p>\n</li></ul>\n\n<p>The constructor function <code>delay</code> is used to delay the construction\nof a computation until the moment where this computation must be\nexecuted. Indeed, a difficulty that arises in a strict programming\nlanguage, such as OCaml, is that the arguments passed to constructor\nfunctions, such as <code>return</code> and <code>choose</code>, are evaluated immediately,\nat construction time. For instance, when one writes <code>choose e1 e2</code>,\nboth of the OCaml expressions <code>e1</code> and <code>e2</code> are evaluated before\n<code>choose</code> is invoked. If the evaluation of <code>e2</code> performs nontrivial\nwork, then this work arguably takes place too early: indeed, there\nshould be no need to evaluate <code>e2</code> until all of the values produced\nby <code>e1</code> have been demanded. To remedy this, one may write <code>choose e1\n(delay (fun () -&gt; e2))</code>. There, the expression <code>e2</code> is placed in the\nbody of an anonymous function, so <code>e2</code> is not evaluated immediately.\nThis anonymous function, whose type is <code>unit -&gt; &#39;a m</code>,\nis converted by <code>delay</code> to a computation of type <code>&#39;a m</code>.\nThis conversion requires no serious work;\nit is performed in constant time.\nAn intuitive reason why this is possible is that the type <code>&#39;a m</code>\nrepresents a <em>suspended</em> computation already,\nso the type <code>unit -&gt; &#39;a m</code> represents a <em>suspended suspended</em>\ncomputation, which is essentially the same thing; these types\nare interconvertible at no cost.</p>\n<p>The computations <code>e</code> and <code>delay (fun () -&gt; e)</code> produce the same\nsequence of results. The only difference between them is the time at\nwhich the evaluation of <code>e</code> takes place: either immediately, or only\nwhen the first result is demanded.</p>\n<p>It is worth noting that in a lazy language, such as Haskell, there\nis no need for <code>delay</code>. In such a language, when one writes <code>choose\ne1 e2</code>, the expressions <code>e1</code> and <code>e2</code> are <em>not</em> evaluated\nimmediately: they are evaluated only when their value is demanded.\nThus, the fact that <code>e2</code> need not be evaluated until all of the\nvalues produced by <code>e1</code> have been demanded goes without saying. The\nfact that there is no need for explicit uses of <code>delay</code> is arguably\na strength of lazy languages. At the same time, the fact that it is\nnot obvious where laziness plays a crucial role is arguably a\nweakness of lazy languages. In OCaml, in contrast, the explicit use\nof <code>delay</code> can be verbose, but helps understand what is going on.</p>\n<p>The constructor function <code>at_most_once</code> constructs a computation\nthat succeeds at most once. If <code>m</code> fails, then <code>at_most_once m</code>\nfails as well. If <code>m</code> produces a result <code>x</code>, possibly followed with\nmore results, then <code>at_most_once m</code> produces just the result <code>x</code>,\nand no more. This combinator can be used to commit to a result and\nprevent any other choices from being explored. In other words, it\nlimits the amount of backtracking that takes place.</p>\n<p>The constructor function <code>interleave</code> has the same type as <code>choose</code>.\nIt is a <em>fair disjunction</em> operator. An ordinary disjunction <code>choose\nm1 m2</code> gives priority to its left branch: it first lets <code>e1</code> produce\nas many results as it wishes, then gives control to <code>e2</code>. This can\nbe problematic: if <code>e1</code> produces a large number of results, then\n<code>e2</code> is tried very late. At an extreme, if <code>e1</code> produces an infinite\nnumber of results, then <code>e2</code> is never tried. For instance, supposing\nthat <code>evens</code> produces the infinite sequence <code>0, 2, 4, ...</code> and\n<code>odds</code> produces the infinite sequence <code>1, 3, 5, ...</code>,\nthe disjunction <code>choose evens odds</code> is equivalent to just <code>evens</code>,\nwhich seems counter-intuitive and undesirable. In contrast,\n<code>interleave</code> is defined in such a way that <code>interleave evens odd</code>\nproduces the infinite sequence <code>0, 1, 2, 3, 4, 5, ...</code>.\nIt is <em>fair</em> in the sense that each branch in turn is allowed\nto produce a result.</p>\n<p>The constructor function <code>(&gt;&gt;-)</code> has the same type as <code>(&gt;&gt;=)</code>.\nIt is a <em>fair sequencing</em> operator.\nIndeed, a problem with ordinary sequencing <code>(&gt;&gt;=)</code> is that\nit gives rise to ordinary (unfair) disjunctions.\nTo see this, suppose that the left-hand argument of <code>(&gt;&gt;=)</code>\nis a computation that produces <code>x</code> as its first result,\nfollowed with a computation <code>m1</code> that may produce more results.\nThus, this left-hand argument is equivalent to\n<code>choose (return x) m1</code>.\nWhen we sequentially compose it with a computation <code>m2</code>,\nwe obtain\n<code>(choose (return x) m1) &gt;&gt;= m2</code>,\nwhich is equivalent to\n<code>choose (return x &gt;&gt;= m2) (m1 &gt;&gt;= m2)</code>,\nwhich itself is the same as\n<code>choose (m2 x) (m1 &gt;&gt;= m2)</code>.\nWe are faced with an ordinary (unfair) disjunction.\nThe problem, again, is that if <code>m2 x</code> produces an\ninfinite number of results, then <code>m1 &gt;&gt;= m2</code>\nis never executed.\nTo remedy this problem,\nthe fair sequencing operator <code>(&gt;&gt;-)</code>\nis defined in such a way that\n<code>choose (return x) m1 &gt;&gt;- m2</code>\nis equivalent to\n<code>interleave (m2 x) (m1 &gt;&gt;- m2)</code>.\nThus, it gives rise to a fair disjunction.</p>\n<h2 id=\"The-Seq-API\">The <code>Seq</code> API</h2>\n\n<p>The type of <strong>on-demand sequences</strong> is defined in a module named <code>Seq</code>.\nBeginning with version 4.07,\nthis module is part of OCaml&#39;s standard library.</p>\n<pre><code>module Seq : sig\n\n  type &#39;a t = unit -&gt; &#39;a node\n\n  and +&#39;a node =\n  | Nil\n  | Cons of &#39;a * &#39;a t\n\n  val nil : &#39;a t\n  val cons: &#39;a -&gt; &#39;a t -&gt; &#39;a t\n  val singleton: &#39;a -&gt; &#39;a t\n\n  val map: (&#39;a -&gt; &#39;b) -&gt; &#39;a t -&gt; &#39;b t\n  val concat: &#39;a t -&gt; &#39;a t -&gt; &#39;a t\n  val flatten: &#39;a t t -&gt; &#39;a t\n\n  val take: int -&gt; &#39;a t -&gt; &#39;a t\n\n  val head: &#39;a t -&gt; &#39;a option\n\n  val of_list: &#39;a list -&gt; &#39;a t\n  val to_list: &#39;a t -&gt; &#39;a list\n\nend</code></pre>\n\n<p>This data type is closely related to the algebraic data type of lists.\nIndeed, if instead of <code>unit -&gt; &#39;a node</code> one had written just <code>&#39;a node</code>,\nthen this data type would have been isomorphic to the type of lists.</p>\n<p>The presence of <code>unit -&gt; ...</code> indicates that a sequence is in fact a function.\nCalling this function, by applying it to the value <code>()</code>, amounts to requesting\nthe head of the sequence. This head can be either <code>Nil</code>, which means that the\nsequence is empty, or <code>Cons (x, xs)</code>, which means that the first element of\nthe sequence is <code>x</code> and the remaining elements form another sequence <code>xs</code>. It\nis worth noting that <code>xs</code> is itself a function, so the elements of the\nsequence <code>xs</code> need not be explicitly computed until <code>xs</code> is applied.</p>\n<p>Sequences are closely related to <em>iterators</em> in object-oriented languages,\nsuch as C++ and Java. Yet, sequences are much simpler than iterators, for\ntwo reasons:</p>\n<ul><li><p>they involve no mutable state;</p>\n</li><li><p>they are just as easy to construct and to use as ordinary lists.</p>\n</li></ul>\n\n<p>The functions <code>nil</code>, <code>cons</code>, and <code>singleton</code> are constructor functions.</p>\n<p>The functions <code>map</code>, <code>concat</code>, <code>flatten</code> are analogues for sequences\nof the standard list functions <code>List.map</code>, <code>(@)</code>, and\n<code>List.flatten</code>.</p>\n<p>The function <code>Seq.take</code> truncates a sequence at a certain length:\n<code>Seq.take n xs</code> is a sequence that begins like <code>xs</code> but has at most\n<code>n</code> elements.</p>\n<p>The function <code>Seq.head</code> demands the first element of a sequence. If\nthe sequence begins with an element <code>x</code>, then <code>Some x</code> is returned;\notherwise, <code>None</code> is returned. This forces enough computation to\ntake place so as to be able to produce the first element of the\nsequence.</p>\n<p>The functions <code>Seq.of_list</code> and <code>Seq.to_list</code> convert between lists\nand sequences, both ways. One must keep in mind that applying\n<code>Seq.to_list</code> to a sequence <code>xs</code> causes all of its elements to be\ndemanded: that is, it forces all of the suspended computations to\ntake place. In particular, if <code>xs</code> is an infinite sequence, then\n<code>Seq.to_list xs</code> does not terminate.</p>\n<h2 id=\"Data-Structures-for-Continuations-and-Computations\">Data Structures for Continuations and Computations</h2>\n\n<p>In this exercise, we implement an abstract machine that manipulates three data\nstructures: a <strong>computation</strong>, a <strong>failure continuation</strong>, and a <strong>success\ncontinuation</strong>. The idea is, in general, the computation indicates what to do\nnext; in the case where the computation is <code>fail</code>, the failure continuation\nindicates what to do next; in the case where the computation is <code>return x</code>,\nthe success continuation indicates what to do next.</p>\n<p>Each of these three data structures is described by a generalized algebraic\ndata type. We now give the definitions of these data types. (These definitions\ncan in fact be <em>deduced</em> from the solution of the\n<a onclick=\"top.location='/exercises/nondet_monad_cont/';\" href=''>companion exercise</a>,\nby defunctionalization, but we leave this story for another time.)</p>\n<p>The type <code>&#39;a m</code> of <strong>computations</strong> is defined as follows:</p>\n<pre><code>type &#39;a m =\n| MDelay:               (unit -&gt; &#39;a m) -&gt; &#39;a m\n| MReturn:                          &#39;a -&gt; &#39;a m\n| MBind:           &#39;a m * (&#39;a -&gt; &#39;b m) -&gt; &#39;b m\n| MFail:                                  &#39;a m\n| MChoose:                 &#39;a m * &#39;a m -&gt; &#39;a m\n| MReflect: (&#39;a * &#39;a m) option failure -&gt; &#39;a m</code></pre>\n\n<p>The data constructors <code>MDelay</code>, <code>MReturn</code>, <code>MBind</code>, <code>MFail</code>, and <code>MChoose</code>\ncorrespond directly to the constructor functions <code>delay</code>, <code>return</code>, <code>&gt;&gt;=</code>,\n<code>fail</code>, and <code>choose</code>. In other words, a computation is represented internally\nby its syntax.</p>\n<p>If <code>f</code> is a failure continuation whose answer type is <code>(&#39;a * &#39;a m) option</code>,\nthen <code>MReflect f</code> is a computation. In other words, the data constructor\n<code>MReflect</code> allows disguising such a failure continuation as a computation.\nThis is useful in the implementation of the operation <code>msplit</code>, which\nitself is used in Question 2-4, as in the\n<a onclick=\"top.location='/exercises/nondet_monad_cont/';\" href=''>companion exercise</a>.</p>\n<p>The type <code>&#39;answer failure</code> of <strong>failure continuations</strong> is defined as follows:</p>\n<pre><code>and &#39;answer failure =\n| FChoose:\n    (* m2: *) &#39;a m *\n    (* s : *) (&#39;a, &#39;answer) success *\n    (* f : *) &#39;answer failure -&gt;\n              &#39;answer failure\n| FSols:\n    _ Seq.node failure\n| FSplit:\n    _ option failure</code></pre>\n\n<p>Thus, a failure continuation is a data structure. This data structure can be\n<em>interpreted</em> as a function of type <code>unit -&gt; &#39;answer</code> by the function\n<code>apply_failure</code>, whose type is\n<code>&#39;answer failure -&gt; unit -&gt; &#39;answer</code>,\nand whose code you have to complete as part of this exercise.\nThere are three data constructors:</p>\n<ul><li><p><code>FChoose (m2, s, f)</code> records the fact that a choice of the form <code>choose m1\n  m2</code> has been entered. The right-hand branch <code>m2</code> as well as the current\n success and failure continuations <code>s</code> and <code>f</code> are recorded, so as to allow\n the computation to continue if and after the left-hand branch <code>m1</code> fails.</p>\n</li><li><p><code>FSols</code> records the fact that this computation is executed by the\n observation function <code>sols</code>. When interpreted as a function, this\n failure continuation returns <code>Seq.Nil</code>.</p>\n</li><li><p><code>FSplit</code> records the fact that this computation is executed by the\n observation function <code>msplit</code>. When interpreted as a function, this\n failure continuation returns <code>None</code>.</p>\n</li></ul>\n\n<p>The type <code>(&#39;a, &#39;answer) success</code> of <strong>success continuations</strong> is defined\nas follows:</p>\n<pre><code>and (&#39;a, &#39;answer) success =\n| SBind:\n    (* m2: *) (&#39;a -&gt; &#39;b m) *\n    (* s : *) (&#39;b, &#39;answer) success -&gt;\n              (&#39;a, &#39;answer) success\n| SSols:\n    (&#39;a, &#39;a Seq.node) success\n| SSplit:\n    (&#39;a, (&#39;a * &#39;a m) option) success</code></pre>\n\n<p>Thus, a success continuation is a data structure. This data structure can be\n<em>interpreted</em> as a function of type <code>&#39;a -&gt; &#39;answer failure -&gt; &#39;answer</code>\nby the function <code>apply_success</code>,\nwhose type is <code>(&#39;a, &#39;answer) success -&gt; &#39;a -&gt; &#39;answer failure -&gt; &#39;answer</code>,\nand whose code you have to complete as part of this exercise.\nThere are three data constructors:</p>\n<ul><li><p><code>SBind (m2, s)</code> records the fact that a sequence of the form <code>m1 &gt;&gt;= m2</code> has\n been entered. The right-hand side of the sequence <code>m2</code> as well as the\n current success continuation <code>s</code> are recorded so as to allow the computation\n to continue if (and every time) <code>m1</code> produces a result.</p>\n</li><li><p><code>SSols</code> records the fact that this computation is executed by the\n observation function <code>sols</code>. When interpreted as a function, this\n success continuation returns an answer of the form <code>Seq.Cons (_, _)</code>.</p>\n</li><li><p><code>SSplit</code> records the fact that this computation is executed by the\n observation function <code>msplit</code>. When interpreted as a function, this\n success continuation returns an answer of the form <code>Some (_, _)</code>.</p>\n</li></ul>\n\n<p>The data types <code>&#39;a m</code>, <code>&#39;answer failure</code> and <code>(&#39;a, &#39;answer) success</code> are\nmutually recursive. Thus, the three functions which interpret these data\ntypes, namely <code>compute</code>, <code>apply_failure</code>, and <code>apply_success</code>, are\nmutually recursive as well.</p>\n<h2 id=\"Implementing-the-Abstract-Machine\">Implementing the Abstract Machine</h2>\n\n<p>The four constructor functions <code>return</code>, <code>(&gt;&gt;=)</code>, <code>fail</code>, and <code>choose</code>\nhave been implemented for you already. They are trivial anyway.</p>\n<p><strong>Question 1.</strong>\nComplete the definitions of the functions\n<code>apply_failure</code>, <code>apply_success</code>, and <code>compute</code>.\nThen, implement the observation function <code>sols</code>.</p>\n<p><em>Note.</em> The automated grading system first tests whether your code\nis functionally correct. To do so, it builds a computation using the\nfour constructor functions, converts it to a sequence via <code>sols</code>,\nand tests whether this produces the expected sequence of results.\nThen, it tests whether your code is lazy, that is, whether each\nresult is computed as late as possible. To do so, it uses a\nconstructor function <code>tick: &#39;a m -&gt; &#39;a m</code> whose effect is as\nfollows: the computation <code>tick m</code> produces the same sequence of\nresults as the computation <code>m</code>, and, when executed, increments a\nglobal counter named <code>work</code>. Thus, by executing computations that\ncontain <code>tick</code>s, the automated grading system can tell when\ncomputations are executed. For instance, demanding just the first\nresult of the computation\n<code>choose (tick (return 0)) (tick (return 1))</code> should cause <code>work</code> to\nbe incremented just once, not twice.</p>\n<p><em>Note.</em> The automated grading system for Question 1 does not exercise the\ncases for <code>FSplit</code>, <code>SSplit</code> and <code>MReflect</code> in the abstract machine. In order\nto ensure that your code deals with these cases correctly, you must continue\nthis exercise and pass Questions 2-4 as well.</p>\n<p>As in the continuation-based implementation described in a\n<a onclick=\"top.location='/exercises/nondet_monad_cont/';\" href=''>companion exercise</a>,\nbefore attacking Questions 2-4,\nwe must define an auxiliary function, <code>msplit</code>.</p>\n<p>The need for <code>msplit</code> arises from the following remark. When executed, a\ncomputation of type <code>&#39;a m</code> produces a sequence of results. Such a sequence\nmust be either empty or nonempty, and in the latter case, it must have a first\nelement and a remainder. If a computation <em>was</em> just a sequence (that is, if\nthe type <code>&#39;a m</code> was a synonym for <code>&#39;a Seq.t</code>), then we could distinguish these\ntwo situations just by performing a case analysis.</p>\n<p>Because we have defined the type <code>&#39;a m</code> in a different way, a direct case\nanalysis is impossible. Instead, the idea is to define a function <code>msplit</code>\nthat <em>converts</em> from the type <code>&#39;a m</code> to the type <code>unit -&gt; (&#39;a * &#39;a m) option</code>.\nThis opens the door to a case analysis. In short, <code>msplit</code> allows us to\nperform case analysis on a computation <em>as if</em> it was a sequence, even though\nits internal representation is different.</p>\n<p><strong>Question X.</strong> (Not graded.)\nComplete the implementation of the auxiliary function <code>msplit.</code></p>\n<p>Once <code>msplit</code> is available,\nQuestions 2-4 are answered in exactly the same way as in the\n<a onclick=\"top.location='/exercises/nondet_monad_cont/';\" href=''>companion exercise</a>.</p>\n<p><strong>Question 2.</strong> Implement the constructor function <code>at_most_once</code>.</p>\n<p><em>Hint.</em> Use <code>msplit</code> to determine if the computation at hand fails or produces\nat least one result. In the first case, recall that <code>at_most_once fail</code> is\nsupposed to behave like <code>fail</code>. In the second case, recall that\n<code>at_most_once (choose (return x) m)</code> is supposed to behave like\n<code>return x</code>.</p>\n<p><em>Hint.</em> Use <code>delay</code> to ensure that the case analysis is performed when\nthe computation <code>at_most_once m</code> is <em>executed</em>, not when it is <em>built</em>.</p>\n<p><strong>Question 3.</strong> Implement the constructor function <code>interleave</code>.</p>\n<p><em>Hint.</em> Again, use <code>delay</code> and <code>msplit</code> in an appropriate manner.\nThen, ask yourself how <code>interleave fail m2</code> is supposed to behave,\nand how <code>interleave (choose (return x1) m1) m2</code> is supposed\nto behave.</p>\n<p><strong>Question 4.</strong> Implement the constructor function <code>(&gt;&gt;-)</code>.</p>\n<p><em>Hint.</em> Again, use <code>delay</code> and <code>msplit</code> in an appropriate manner.\nThen, ask yourself how <code>fail &gt;&gt;- m2</code> is supposed to behave,\nand how <code>(choose (return x1) m1) &gt;&gt;- m2</code> is supposed\nto behave.</p>\n<h2 id=\"Notes\">Notes</h2>\n\n<p>This implementation can be obtained from the continuation-based implementation studied in\n<a onclick=\"top.location='/exercises/nondet_monad_cont/';\" href=''>another exercise</a>\nin a systematic manner by performing\n<a href='https://en.wikipedia.org/wiki/Defunctionalization'>defunctionalization</a>.\nThis is in fact arguably a rather natural way of discovering this\nimplementation, as it could otherwise be difficult to <em>guess</em> the\ndefinitions of the algebraic data types <code>_ failure</code>,\n<code>(_, _) success</code>, and <code>_ m</code>.\nThe paper\n<strong>Polymorphic typed defunctionalization and concretization</strong>\n<a href='http://gallium.inria.fr/~fpottier/publis/fpottier-gauthier-hosc.pdf'>(Pottier and Gauthier, 2006)</a>\nexplains how defunctionalization\ngives rise to a generalized algebraic data type\nand an <code>apply</code> function\nin the transformed program.\nHere, the process gives rise to three generalized algebraic data types\nand three <code>apply</code> functions, because we defunctionalize computations,\nsuccess continuations, and failure continuations independently.</p>\n<p>One potential advantage of the defunctionalized version is the fact that it\ncan be implemented in a programming language that does not support first-class\nfunctions, such as C.</p>\n"
      ]
    ],
    "prepare": "VwQ5Gy4Ak6i7y9AXLVzK",
    "test": "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",
    "solution": "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",
    "max-score": 8,
    "depend": null,
    "dependencies": []
  },
  null
]